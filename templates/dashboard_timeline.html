{% extends "base.html" %}

{% block title %}Dashboard de Cronograma - Cronograma{% endblock %}

{% block breadcrumbs %}
    &raquo; Dashboard de Cronograma
{% endblock %}

{% block content %}
<div class="card">
    <h2>
        Dashboard de Cronograma (Gantt)
        <a href="{{ url_for('export_dashboard_timeline', **request.args) }}" class="link-button" style="margin-left: 16px;">
            üì• Exportar para Excel
        </a>
    </h2>
    <p class="small-text">Visualize o cronograma de todos os projetos e suas hierarquias em uma linha do tempo interativa.</p>
</div>

<div class="card">
    <h3>Filtros</h3>
    <form method="GET" action="{{ url_for('dashboard_timeline') }}">
        <div class="project-form-fields">
            <div class="field">
                <label for="status">Status do projeto</label>
                <select id="status" name="status" multiple>
                    {% for status in filter_options.statuses %}
                        <option value="{{ status }}" {% if status in (current_filters.status if current_filters.status is iterable and current_filters.status is not string else [current_filters.status] if current_filters.status else []) %}selected{% endif %}>
                            {{ status }}
                        </option>
                    {% endfor %}
                </select>
            </div>

            <div class="field">
                <label for="requesting_agency">√ìrg√£o demandante</label>
                <select id="requesting_agency" name="requesting_agency" multiple>
                    {% for agency in filter_options.requesting_agencies %}
                        <option value="{{ agency }}" {% if agency in (current_filters.requesting_agency if current_filters.requesting_agency is iterable and current_filters.requesting_agency is not string else [current_filters.requesting_agency] if current_filters.requesting_agency else []) %}selected{% endif %}>
                            {{ agency }}
                        </option>
                    {% endfor %}
                </select>
            </div>

            <div class="field">
                <label for="coordinator">Coordenador</label>
                <select id="coordinator" name="coordinator" multiple>
                    {% for coord in filter_options.coordinators %}
                        <option value="{{ coord }}" {% if coord in (current_filters.coordinator if current_filters.coordinator is iterable and current_filters.coordinator is not string else [current_filters.coordinator] if current_filters.coordinator else []) %}selected{% endif %}>
                            {{ coord }}
                        </option>
                    {% endfor %}
                </select>
            </div>

            <div class="field">
                <label for="project_type">Tipo de projeto</label>
                <select id="project_type" name="project_type" multiple>
                    <option value="robot" {% if "robot" in (current_filters.project_type if current_filters.project_type is iterable and current_filters.project_type is not string else [current_filters.project_type] if current_filters.project_type else []) %}selected{% endif %}>Rob√¥</option>
                    <option value="system" {% if "system" in (current_filters.project_type if current_filters.project_type is iterable and current_filters.project_type is not string else [current_filters.project_type] if current_filters.project_type else []) %}selected{% endif %}>Sistema</option>
                    <option value="both" {% if "both" in (current_filters.project_type if current_filters.project_type is iterable and current_filters.project_type is not string else [current_filters.project_type] if current_filters.project_type else []) %}selected{% endif %}>Rob√¥ e Sistema</option>
                    <option value="none" {% if "none" in (current_filters.project_type if current_filters.project_type is iterable and current_filters.project_type is not string else [current_filters.project_type] if current_filters.project_type else []) %}selected{% endif %}>Nenhum</option>
                </select>
            </div>

            <div class="field">
                <label for="date_start">Data in√≠cio (per√≠odo)</label>
                <input type="date" id="date_start" name="date_start" value="{{ current_filters.date_start }}">
            </div>

            <div class="field">
                <label for="date_end">Data fim (per√≠odo)</label>
                <input type="date" id="date_end" name="date_end" value="{{ current_filters.date_end }}">
            </div>
        </div>

        <div style="margin-top: 16px;">
            <button type="submit">Filtrar</button>
            <a href="{{ url_for('dashboard_timeline') }}" class="link-button" style="margin-left: 8px;">Limpar filtros</a>
        </div>
    </form>
</div>

<div class="card">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
        <h3 style="margin: 0;">Cronograma</h3>
        <div class="field" style="margin: 0; display: flex; align-items: center; gap: 8px;">
            <label for="view-mode-select" style="margin: 0; font-weight: normal;">Visualiza√ß√£o:</label>
            <select id="view-mode-select" style="min-width: 120px;">
                <option value="Day">Dia</option>
                <option value="Week">Semana</option>
                <option value="Month" selected>M√™s</option>
                <option value="Year">Ano</option>
            </select>
        </div>
    </div>
    {% if timeline_data|length == 0 %}
        <div style="padding: 20px; background-color: #fff3cd; border: 1px solid #ffc107; border-radius: 4px; margin-bottom: 16px;">
            <p style="margin: 0; color: #856404;"><strong>Aten√ß√£o:</strong> Nenhum projeto encontrado com os filtros aplicados ou nenhum projeto possui datas v√°lidas (start_date e end_date).</p>
            <p style="margin: 8px 0 0 0; color: #856404; font-size: 0.9rem;">Para que um projeto apare√ßa no cronograma, ele precisa ter tanto a data de in√≠cio quanto a data de fim preenchidas. Essas datas s√£o calculadas automaticamente a partir das tarefas do projeto.</p>
        </div>
    {% else %}
        <p class="small-text" style="margin-bottom: 8px;">Exibindo {{ timeline_data|length }} item{{ 's' if timeline_data|length != 1 else '' }} no cronograma.</p>
    {% endif %}
    <!-- SOLU√á√ÉO: Wrapper com scroll e cabe√ßalho fixo usando CSS sticky -->
    <!-- IMPORTANTE: width: 100% para for√ßar o container e permitir que o conte√∫do interno crie scroll -->
    <div id="gantt-wrapper" style="position: relative; max-height: 800px; width: 100%; overflow-y: auto; overflow-x: auto; border: 1px solid #ddd; border-radius: 4px; background: white;">
        <!-- Container do Gantt com largura m√≠nima para for√ßar scroll horizontal -->
        <div id="gantt-container" style="min-height: 600px; min-width: 100%; display: inline-block;"></div>
    </div>
</div>
{% endblock %}

{% block extra_scripts %}
<!-- frappe-gantt CSS -->
<link rel="stylesheet" href="https://unpkg.com/frappe-gantt@0.6.1/dist/frappe-gantt.css">

<!-- frappe-gantt JavaScript -->
<script src="https://unpkg.com/frappe-gantt@0.6.1/dist/frappe-gantt.min.js"></script>

<script>
// Dados da timeline em formato JSON
const timelineData = {{ timeline_data | tojson }};

// Debug: verifica se os dados foram carregados
console.log('Timeline data:', timelineData);
console.log('Number of items:', timelineData ? timelineData.length : 0);

// Inicializa o gr√°fico Gantt quando a p√°gina carregar
document.addEventListener("DOMContentLoaded", function() {
    const container = document.getElementById('gantt-container');
    
    if (!container) {
        console.error('Container #gantt-container n√£o encontrado!');
        return;
    }

    // Verifica se o Gantt est√° dispon√≠vel
    if (typeof Gantt === 'undefined') {
        console.error('Biblioteca frappe-gantt n√£o foi carregada!');
        container.innerHTML = '<p style="padding: 20px; text-align: center; color: #d00;">Erro: Biblioteca Gantt n√£o foi carregada. Verifique a conex√£o com a internet.</p>';
        return;
    }

    if (timelineData && timelineData.length > 0) {
        console.log('Inicializando Gantt com', timelineData.length, 'itens');
        
        try {
            // Primeiro, valida e filtra os dados
            const validItems = timelineData.filter(function(item) {
                // Valida que todos os campos obrigat√≥rios existem
                if (!item.id || !item.name || !item.start || !item.end) {
                    console.warn('Item inv√°lido ignorado:', item);
                    return false;
                }
                // Valida formato das datas
                if (typeof item.start !== 'string' || typeof item.end !== 'string') {
                    console.warn('Item com datas inv√°lidas ignorado:', item);
                    return false;
                }
                // Valida que a data de in√≠cio √© anterior √† data de fim
                if (new Date(item.start) > new Date(item.end)) {
                    console.warn('Item com datas invertidas ignorado:', item);
                    return false;
                }
                return true;
            });

            console.log('Itens v√°lidos:', validItems.length, 'de', timelineData.length);

            // Cria um mapa de IDs v√°lidos para validar depend√™ncias
            const validIds = new Set(validItems.map(item => item.id));

            // Prepara os dados no formato correto para frappe-gantt
            // IMPORTANTE: Removendo depend√™ncias temporariamente para evitar erros
            // O frappe-gantt pode ter problemas com depend√™ncias que referenciam itens que n√£o existem
            let ganttData = validItems.map(function(item) {
                // Por enquanto, n√£o usamos depend√™ncias para evitar o erro
                // As barras aparecer√£o todas no mesmo n√≠vel, mas funcionar√°
                return {
                    id: String(item.id),
                    name: String(item.name),
                    start: String(item.start),
                    end: String(item.end),
                    progress: Number(item.progress) || 0
                    // dependencies removido temporariamente
                };
            });

            console.log('Dados preparados para Gantt:', ganttData.length, 'itens');
            console.log('Primeiros 3 itens:', ganttData.slice(0, 3));
            
            // Valida√ß√£o final antes de passar para o Gantt
            if (!Array.isArray(ganttData)) {
                throw new Error('ganttData n√£o √© um array: ' + typeof ganttData);
            }
            
            if (ganttData.length === 0) {
                throw new Error('Nenhum item v√°lido para exibir no Gantt');
            }
            
            // Verifica se todos os itens t√™m os campos obrigat√≥rios
            const invalidItems = ganttData.filter(item => {
                const hasId = item && item.id;
                const hasName = item && item.name;
                const hasStart = item && item.start;
                const hasEnd = item && item.end;
                return !hasId || !hasName || !hasStart || !hasEnd;
            });
            
            if (invalidItems.length > 0) {
                console.error('Itens inv√°lidos encontrados:', invalidItems.length);
                console.error('Exemplo de item inv√°lido:', invalidItems[0]);
                // Remove itens inv√°lidos em vez de lan√ßar erro
                const validGanttData = ganttData.filter(item => {
                    return item && item.id && item.name && item.start && item.end;
                });
                console.warn('Removidos', ganttData.length - validGanttData.length, 'itens inv√°lidos');
                ganttData = validGanttData;
                
                if (ganttData.length === 0) {
                    throw new Error('Todos os itens foram removidos por serem inv√°lidos');
                }
            }

            console.log('Inicializando Gantt com', ganttData.length, 'itens v√°lidos...');
            console.log('Exemplo de item v√°lido:', ganttData[0]);
            
            // Salva ganttData em uma vari√°vel acess√≠vel globalmente para a fun√ß√£o applyColors
            window.ganttDataForColors = ganttData;
            
            // FASE 2: Seletor de modo de visualiza√ß√£o
            // Carrega prefer√™ncia salva ou usa 'Month' como padr√£o
            const VIEW_MODE_KEY = 'gantt-view-mode';
            const savedViewMode = localStorage.getItem(VIEW_MODE_KEY) || 'Month';
            
            // Configura√ß√£o m√≠nima do Gantt para evitar erros
            const ganttConfig = {
                view_mode: savedViewMode,
                header_height: 100,
                column_width: 30,
                step: 24,
                bar_height: 20,
                bar_corner_radius: 3,
                arrow_curve: 5,
                padding: 18,
                date_format: 'YYYY-MM-DD',
                on_click: function (task) {
                    // Ao clicar em uma barra, navega para a URL associada
                    try {
                        const taskId = task._id || task.id;
                        const originalTask = timelineData.find(t => t.id === taskId);
                        if (originalTask && originalTask.url) {
                            window.location.href = originalTask.url;
                        }
                    } catch (e) {
                        console.error('Erro no clique:', e);
                    }
                }
            };
            
            // Remove callbacks opcionais que podem causar problemas
            // on_date_change, on_progress_change, on_view_change removidos temporariamente
            
            let gantt;
            try {
                gantt = new Gantt("#gantt-container", ganttData, ganttConfig);
                console.log('Gantt criado com sucesso');
            } catch (initError) {
                console.error('Erro ao criar inst√¢ncia do Gantt:', initError);
                console.error('Stack trace:', initError.stack);
                console.error('Dados que causaram o erro (primeiros 5):', ganttData.slice(0, 5));
                throw initError;
            }

            console.log('Gantt inicializado com sucesso');
            
            // FASE 2: Implementar seletor de modo de visualiza√ß√£o
            // VIEW_MODE_KEY e savedViewMode j√° foram declarados acima
            const viewModeSelect = document.getElementById('view-mode-select');
            
            // Carregar prefer√™ncia salva e aplicar no dropdown
            if (viewModeSelect) {
                viewModeSelect.value = savedViewMode;
                
                // Se a prefer√™ncia salva for diferente de 'Month', aplicar no gantt
                // (Mas como j√° foi aplicado no ganttConfig, s√≥ precisa atualizar o dropdown)
                // Ainda assim, vamos garantir que est√° sincronizado
                if (gantt && savedViewMode !== ganttConfig.view_mode) {
                    // Aguarda um pouco para garantir que o gantt est√° totalmente inicializado
                    setTimeout(function() {
                        if (gantt && typeof gantt.change_view_mode === 'function') {
                            gantt.change_view_mode(savedViewMode);
                        }
                    }, 100);
                }
            }
            
            // Event listener para mudan√ßas no dropdown
            if (viewModeSelect && gantt) {
                viewModeSelect.addEventListener('change', function(e) {
                    const selectedMode = e.target.value;
                    
                    // Salva prefer√™ncia no localStorage
                    localStorage.setItem(VIEW_MODE_KEY, selectedMode);
                    
                    // Aplica o modo de visualiza√ß√£o
                    if (gantt && typeof gantt.change_view_mode === 'function') {
                        console.log('Alterando modo de visualiza√ß√£o para:', selectedMode);
                        gantt.change_view_mode(selectedMode);
                    } else {
                        console.warn('gantt.change_view_mode n√£o est√° dispon√≠vel');
                    }
                });
                
                console.log('Seletor de visualiza√ß√£o configurado');
            }

            // FASE 1: FUN√á√ÉO DE DEBUG PARA MAPEAR ESTRUTURA COMPLETA DO SVG
            // E identificar elementos do cabe√ßalho (header)
            const debugSVGStructure = function(svg) {
                console.log('=== DEBUG: ESTRUTURA COMPLETA DO SVG ===');
                
                const headerHeight = ganttConfig.header_height || 50;
                console.log('Altura do cabe√ßalho configurada:', headerHeight);
                
                // Identifica elementos do cabe√ßalho (Y < headerHeight)
                const allElements = Array.from(svg.querySelectorAll('*'));
                const headerElements = allElements.filter(function(el) {
                    const y = parseFloat(el.getAttribute('y') || 0);
                    return y < headerHeight && y >= 0;
                });
                
                console.log('Total de elementos no cabe√ßalho (Y < ' + headerHeight + '):', headerElements.length);
                
                // Identifica tipos de elementos no cabe√ßalho
                const headerTexts = headerElements.filter(el => el.tagName === 'text');
                const headerRects = headerElements.filter(el => el.tagName === 'rect');
                const headerLines = headerElements.filter(el => el.tagName === 'line');
                const headerGroups = headerElements.filter(el => el.tagName === 'g');
                
                console.log('  - Textos (datas):', headerTexts.length);
                console.log('  - Ret√¢ngulos:', headerRects.length);
                console.log('  - Linhas:', headerLines.length);
                console.log('  - Grupos:', headerGroups.length);
                
                // Loga primeiros elementos do cabe√ßalho como exemplo
                if (headerTexts.length > 0) {
                    console.log('Primeiros textos do cabe√ßalho:');
                    headerTexts.slice(0, 5).forEach(function(text, idx) {
                        const y = parseFloat(text.getAttribute('y') || 0);
                        const content = text.textContent || '';
                        console.log('  Text', idx + 1, '- Y:', y, 'Conte√∫do:', content);
                    });
                }
                
                // Encontra todos os grupos bar-wrapper
                const barWrappers = Array.from(svg.querySelectorAll('g.bar-wrapper'));
                console.log('Total de grupos bar-wrapper encontrados:', barWrappers.length);
                
                // Analisa os primeiros 10 grupos em detalhe
                const groupsToAnalyze = barWrappers.slice(0, 10);
                groupsToAnalyze.forEach(function(group, groupIdx) {
                    const groupId = group.id || '';
                    const groupClass = group.getAttribute('class') || '';
                    const dataTaskId = group.getAttribute('data-task-id') || '';
                    const dataId = group.getAttribute('data-id') || '';
                    
                    console.log(`\n--- Grupo bar-wrapper ${groupIdx + 1} ---`);
                    console.log('  ID:', groupId || '(vazio)');
                    console.log('  Class:', groupClass);
                    console.log('  data-task-id:', dataTaskId || '(vazio)');
                    console.log('  data-id:', dataId || '(vazio)');
                    
                    // Encontra todos os elementos dentro do grupo
                    const allRects = Array.from(group.querySelectorAll('rect'));
                    const allTexts = Array.from(group.querySelectorAll('text'));
                    const allGroups = Array.from(group.querySelectorAll('g'));
                    
                    console.log('  Elementos dentro do grupo:');
                    console.log('    - Rects:', allRects.length);
                    console.log('    - Texts:', allTexts.length);
                    console.log('    - Grupos aninhados:', allGroups.length);
                    
                    // Analisa cada rect em detalhe
                    allRects.forEach(function(rect, rectIdx) {
                        const x = parseFloat(rect.getAttribute('x') || 0);
                        const y = parseFloat(rect.getAttribute('y') || 0);
                        const width = parseFloat(rect.getAttribute('width') || 0);
                        const height = parseFloat(rect.getAttribute('height') || 0);
                        const fill = rect.getAttribute('fill') || '';
                        const stroke = rect.getAttribute('stroke') || '';
                        const classAttr = rect.getAttribute('class') || '';
                        const dataItemId = rect.getAttribute('data-item-id') || '';
                        const dataCustomColor = rect.getAttribute('data-custom-color') || '';
                        const style = rect.getAttribute('style') || '';
                        
                        // Verifica se √© barra de progresso
                        const isProgress = height > 8 && height < 60 && width > height;
                        
                        console.log(`    Rect ${rectIdx + 1}:`);
                        console.log('      Posi√ß√£o:', `x=${x}, y=${y}, w=${width}, h=${height}`);
                        console.log('      Cores:', `fill=${fill}, stroke=${stroke}`);
                        console.log('      Class:', classAttr || '(vazio)');
                        console.log('      data-item-id:', dataItemId || '(vazio)');
                        console.log('      data-custom-color:', dataCustomColor || '(vazio)');
                        console.log('      Style:', style.substring(0, 100) || '(vazio)');
                        console.log('      √â barra de progresso?', isProgress);
                        
                        // Verifica computed style
                        const computedFill = window.getComputedStyle(rect).fill;
                        const computedStroke = window.getComputedStyle(rect).stroke;
                        console.log('      Computed fill:', computedFill);
                        console.log('      Computed stroke:', computedStroke);
                    });
                    
                    // Analisa grupos aninhados (bar-group)
                    allGroups.forEach(function(nestedGroup, nestedIdx) {
                        const nestedClass = nestedGroup.getAttribute('class') || '';
                        const nestedRects = nestedGroup.querySelectorAll('rect');
                        console.log(`    Grupo aninhado ${nestedIdx + 1} (${nestedClass}):`, nestedRects.length, 'rects');
                    });
                });
                
                // Estat√≠sticas gerais
                console.log('\n=== ESTAT√çSTICAS GERAIS ===');
                let totalRects = 0;
                let progressBars = 0;
                let coloredBars = 0;
                
                barWrappers.forEach(function(group) {
                    const rects = group.querySelectorAll('rect');
                    totalRects += rects.length;
                    
                    rects.forEach(function(rect) {
                        const height = parseFloat(rect.getAttribute('height') || 0);
                        const width = parseFloat(rect.getAttribute('width') || 0);
                        if (height > 8 && height < 60 && width > height) {
                            progressBars++;
                        }
                        if (rect.getAttribute('data-custom-color')) {
                            coloredBars++;
                        }
                    });
                });
                
                console.log('Total de rects em bar-wrappers:', totalRects);
                console.log('Barras de progresso identificadas:', progressBars);
                console.log('Barras com data-custom-color:', coloredBars);
            };
            
            // Executa debug ap√≥s renderiza√ß√£o
            setTimeout(function() {
                const svg = container.querySelector('svg');
                if (svg) {
                    debugSVGStructure(svg);
                }
            }, 1500);

            // Cria um mapa de IDs para cores e URLs (mant√©m refer√™ncia aos dados originais)
            const itemMetadata = {};
            timelineData.forEach(function(item) {
                if (item.id) {
                    itemMetadata[item.id] = {
                        custom_class: item.custom_class,
                        url: item.url,
                        name: item.name
                    };
                }
            });
            
            console.log('Mapa de metadados criado com', Object.keys(itemMetadata).length, 'itens');

            // Flag global para evitar loop infinito no MutationObserver
            let isApplyingColors = false;
            let applyColorsTimeout = null;
            
            // FASE 3: MELHORAR CSS DIN√ÇMICO
            // Fun√ß√£o para criar/atualizar CSS din√¢mico baseado em data-item-id
            // Deve ser definida antes de applyColors para poder ser chamada dentro dela
            const updateDynamicCSS = function(timelineData) {
                // Remove stylesheet anterior se existir
                const existingStyle = document.getElementById('gantt-dynamic-colors');
                if (existingStyle) {
                    existingStyle.remove();
                }
                
                // Cria novo stylesheet
                const style = document.createElement('style');
                style.id = 'gantt-dynamic-colors';
                
                // Define as cores fixas
                const colors = {
                    'gantt-project': { fill: '#1a73e8', stroke: '#1a73e8', strokeWidth: '2' },
                    'gantt-macro': { fill: '#34a853', stroke: '#34a853', strokeWidth: '1.5' },
                    'gantt-stage': { fill: '#fbbc04', stroke: '#fbbc04', strokeWidth: '1' },
                    'gantt-task': { fill: '#9aa0a6', stroke: '#9aa0a6', strokeWidth: '0.5' }
                };
                
                let cssRules = '';
                
                // Gera regras CSS para cada item baseado em m√∫ltiplos seletores
                if (timelineData && Array.isArray(timelineData)) {
                    timelineData.forEach(function(item) {
                        if (item && item.id && item.custom_class) {
                            const itemColors = colors[item.custom_class];
                            if (itemColors) {
                                // FASE 3: Seletores mais espec√≠ficos e m√∫ltiplos
                                // 1. Seletor por data-item-id (mais espec√≠fico)
                                cssRules += `#gantt-container svg rect[data-item-id="${item.id}"] { `;
                                cssRules += `fill: ${colors.fill} !important; `;
                                cssRules += `stroke: ${colors.stroke} !important; `;
                                cssRules += `stroke-width: ${colors.strokeWidth} !important; `;
                                cssRules += `}\n`;
                                
                                // 2. Seletor por classe customizada
                                const classType = item.custom_class.replace('gantt-', '');
                                cssRules += `#gantt-container svg rect.gantt-${classType}[data-item-id="${item.id}"] { `;
                                cssRules += `fill: ${colors.fill} !important; `;
                                cssRules += `stroke: ${colors.stroke} !important; `;
                                cssRules += `stroke-width: ${colors.strokeWidth} !important; `;
                                cssRules += `}\n`;
                                
                                // 3. Seletor combinando classe e data-custom-color
                                cssRules += `#gantt-container svg rect.gantt-custom-colored[data-item-id="${item.id}"] { `;
                                cssRules += `fill: ${colors.fill} !important; `;
                                cssRules += `stroke: ${colors.stroke} !important; `;
                                cssRules += `stroke-width: ${colors.strokeWidth} !important; `;
                                cssRules += `}\n`;
                                
                                // 4. Seletor para barras dentro de grupos com data-item-id
                                cssRules += `#gantt-container svg g[data-item-id="${item.id}"] rect { `;
                                cssRules += `fill: ${colors.fill} !important; `;
                                cssRules += `stroke: ${colors.stroke} !important; `;
                                cssRules += `stroke-width: ${colors.strokeWidth} !important; `;
                                cssRules += `}\n`;
                            }
                        }
                    });
                }
                
                style.textContent = cssRules;
                document.head.appendChild(style);
                
                console.log('CSS din√¢mico atualizado com', timelineData ? timelineData.length * 4 : 0, 'regras (4 seletores por item)');
            };
            
            // Fun√ß√£o para aplicar cores baseado no custom_class do backend
            // Define a fun√ß√£o dentro do escopo onde todas as vari√°veis est√£o dispon√≠veis
            const applyColors = function() {
                // Debounce: cancela execu√ß√£o anterior se houver uma pendente
                if (applyColorsTimeout) {
                    clearTimeout(applyColorsTimeout);
                    applyColorsTimeout = null;
                }
                
                // Se j√° est√° aplicando cores, ignora esta chamada
                if (isApplyingColors) {
                    console.log('applyColors j√° em execu√ß√£o, ignorando chamada duplicada');
                    return;
                }
                
                isApplyingColors = true;
                console.log('=== applyColors chamada ===');
                
                // Atualiza a classe do container para CSS fallback
                const container = document.getElementById('gantt-container');
                if (!container) {
                    console.error('Container #gantt-container n√£o encontrado!');
                    return;
                }
                
                container.classList.remove('color-scheme-colors', 'color-scheme-grayscale');
                container.classList.add('color-scheme-colors');
                
                // Define as cores fixas baseadas no custom_class
                const colors = {
                    'gantt-project': { fill: '#1a73e8', stroke: '#1a73e8', strokeWidth: '2' }, // Azul
                    'gantt-macro': { fill: '#34a853', stroke: '#34a853', strokeWidth: '1.5' }, // Verde
                    'gantt-stage': { fill: '#fbbc04', stroke: '#fbbc04', strokeWidth: '1' }, // Amarelo
                    'gantt-task': { fill: '#9aa0a6', stroke: '#9aa0a6', strokeWidth: '0.5' } // Cinza
                };
                
                const svg = container.querySelector('svg');
                if (!svg) {
                    console.warn('SVG n√£o encontrado no container');
                    return;
                }
                
                // N√£o limpa cores aqui - a fun√ß√£o applyColors principal j√° aplica as cores corretamente
                // Limpar aqui causaria problemas porque as cores seriam removidas antes de serem aplicadas
                
                // Encontra todas as linhas (rows) no SVG que cont√™m barras
                // O frappe-gantt geralmente coloca as barras em grupos espec√≠ficos
                const allRows = Array.from(svg.querySelectorAll('g'));
                const rowsWithBars = [];
                
                // Fun√ß√£o auxiliar para verificar se um rect √© uma barra de progresso PRINCIPAL (vis√≠vel)
                // O frappe-gantt pode ter m√∫ltiplas barras: fundo, progresso, hover, etc.
                // Esta fun√ß√£o identifica a barra principal que deve ser colorida
                const isProgressBar = function(rect) {
                    const height = parseFloat(rect.getAttribute('height') || 0);
                    const width = parseFloat(rect.getAttribute('width') || 0);
                    const x = parseFloat(rect.getAttribute('x') || 0);
                    const y = parseFloat(rect.getAttribute('y') || 0);
                    const fill = rect.getAttribute('fill') || '';
                    const classAttr = rect.getAttribute('class') || '';
                    const opacity = parseFloat(rect.getAttribute('opacity') || 1);
                    
                    // Barras de progresso principais t√™m caracter√≠sticas espec√≠ficas:
                    // 1. Altura entre 8-60px (altura t√≠pica de uma barra)
                    // 2. Largura maior que altura (barras s√£o horizontais)
                    // 3. Posicionadas na √°rea de conte√∫do (x > 0, y > 50 para evitar grid)
                    // 4. N√£o s√£o linhas de grid (grid tem height < 2px ou width < 2px)
                    // 5. N√£o s√£o fundos (fundos geralmente t√™m width/height muito grandes)
                    // 6. N√£o s√£o barras de progresso interno (geralmente menores e com opacity diferente)
                    // 7. Geralmente t√™m fill vis√≠vel (n√£o transparente)
                    
                    // Verifica se tem a classe "bar" (barras principais t√™m essa classe)
                    const hasBarClass = classAttr.includes('bar') && !classAttr.includes('bar-progress') && !classAttr.includes('handle');
                    
                    // Se tem classe "bar", √© uma barra principal (menos restritivo)
                    if (hasBarClass) {
                        const isValidSize = height > 8 && height < 60 && width >= 5; // width >= 5 aceita barras pequenas
                        const isValidPosition = x > 0 && y > 50 && y < 10000; // Y < 10000 para aceitar todas as barras
                        const isNotGrid = !(height < 2 || width < 2);
                        const isNotBackground = !(width > 5000 || height > 5000);
                        const isNotHandle = !classAttr.includes('handle');
                        
                        // Verifica se n√£o est√° em um grupo de hover ou estado especial
                        const parentGroup = rect.closest('g');
                        const parentClass = parentGroup ? (parentGroup.getAttribute('class') || '') : '';
                        const isNotHoverState = !parentClass.includes('hover') && !parentClass.includes('selected');
                        
                        return isValidSize && isValidPosition && isNotGrid && isNotBackground && isNotHandle && isNotHoverState;
                    }
                    
                    // Fallback: verifica outras caracter√≠sticas (mais restritivo)
                    const isValidSize = height > 8 && height < 60 && width >= 5;
                    const isValidPosition = x > 0 && y > 50 && y < 10000;
                    const isNotGrid = !(height < 2 || width < 2);
                    const isNotBackground = !(width > 5000 || height > 5000);
                    const isNotHandle = !classAttr.includes('handle');
                    
                    // Verifica se n√£o est√° em um grupo de hover ou estado especial
                    const parentGroup = rect.closest('g');
                    const parentClass = parentGroup ? (parentGroup.getAttribute('class') || '') : '';
                    const isNotHoverState = !parentClass.includes('hover') && !parentClass.includes('selected');
                    
                    return isValidSize && isValidPosition && isNotGrid && isNotBackground && isNotHandle && isNotHoverState;
                };
                
                // Fun√ß√£o auxiliar para verificar se uma barra est√° na √°rea vis√≠vel do viewport
                // ATEN√á√ÉO: Esta fun√ß√£o foi muito relaxada para aceitar todas as barras v√°lidas
                const isBarVisible = function(rect) {
                    const rectY = parseFloat(rect.getAttribute('y') || 0);
                    const rectHeight = parseFloat(rect.getAttribute('height') || 0);
                    const rectX = parseFloat(rect.getAttribute('x') || 0);
                    const rectWidth = parseFloat(rect.getAttribute('width') || 0);
                    const classAttr = rect.getAttribute('class') || '';
                    
                    // Se tem classe "bar" e n√£o √© handle/progress, assume que √© vis√≠vel
                    if (classAttr.includes('bar') && !classAttr.includes('bar-progress') && !classAttr.includes('handle')) {
                        // Verifica apenas se n√£o est√° muito fora do range (Y < 10000 para ser muito permissivo)
                        return rectY >= 0 && rectY < 10000 && rectWidth >= 0 && rectHeight > 0;
                    }
                    
                    // Verifica se a barra est√° dentro de um range Y razo√°vel (√°rea vis√≠vel t√≠pica)
                    // Aumentado o limite para 10000 para n√£o rejeitar barras v√°lidas
                    const isInVisibleRange = rectY >= 0 && rectY < 10000;
                    
                    // Verifica se tem tamanho razo√°vel (muito relaxado - width >= 0 aceita at√© barras vazias temporariamente)
                    const hasValidSize = rectWidth >= 0 && rectHeight > 0;
                    
                    // Verifica computed style para ver se est√° realmente vis√≠vel
                    const computed = window.getComputedStyle(rect);
                    const isComputedVisible = computed.visibility !== 'hidden' && 
                                             computed.display !== 'none' && 
                                             parseFloat(computed.opacity || 1) > 0.1;
                    
                    return isInVisibleRange && hasValidSize && isComputedVisible;
                };
                
                // Fun√ß√£o auxiliar para identificar a barra principal dentro de um grupo
                // Retorna a barra que deve ser colorida (geralmente a maior ou mais vis√≠vel)
                const getMainBarFromGroup = function(group) {
                    const allRects = Array.from(group.querySelectorAll('rect'));
                    
                    // PRIORIDADE 1: Busca barras com classe "bar" (n√£o bar-progress, n√£o handle)
                    const barClassRects = allRects.filter(function(rect) {
                        const classAttr = rect.getAttribute('class') || '';
                        return classAttr.includes('bar') && 
                               !classAttr.includes('bar-progress') && 
                               !classAttr.includes('handle');
                    });
                    
                    if (barClassRects.length > 0) {
                        // Se h√° m√∫ltiplas, escolhe a maior (mais larga)
                        return barClassRects.reduce(function(largest, current) {
                            const largestWidth = parseFloat(largest.getAttribute('width') || 0);
                            const currentWidth = parseFloat(current.getAttribute('width') || 0);
                            return currentWidth > largestWidth ? current : largest;
                        });
                    }
                    
                    // PRIORIDADE 2: Usa isProgressBar (mais restritivo)
                    const progressBars = allRects.filter(rect => isProgressBar(rect));
                    
                    if (progressBars.length > 0) {
                        // Filtra apenas barras vis√≠veis primeiro
                        const visibleBars = progressBars.filter(rect => isBarVisible(rect));
                        
                        // Se h√° barras vis√≠veis, usa apenas elas
                        const barsToConsider = visibleBars.length > 0 ? visibleBars : progressBars;
                        
                        // Se h√° apenas uma barra, retorna ela
                        if (barsToConsider.length === 1) {
                            return barsToConsider[0];
                        }
                        
                        // Se h√° m√∫ltiplas, escolhe a que est√° mais pr√≥xima do topo (menor Y) e maior largura
                        return barsToConsider.reduce(function(best, current) {
                            const bestY = parseFloat(best.getAttribute('y') || 999999);
                            const currentY = parseFloat(current.getAttribute('y') || 999999);
                            const bestWidth = parseFloat(best.getAttribute('width') || 0);
                            const currentWidth = parseFloat(current.getAttribute('width') || 0);
                            
                            // Prioriza barras mais pr√≥ximas do topo (menor Y)
                            // Se Y √© similar (diferen√ßa < 100), prioriza a mais larga
                            if (Math.abs(bestY - currentY) < 100) {
                                return currentWidth > bestWidth ? current : best;
                            }
                            return currentY < bestY ? current : best;
                        });
                    }
                    
                    // PRIORIDADE 3: Fallback - retorna primeira rect que n√£o √© handle/progress
                    const fallbackBars = allRects.filter(function(rect) {
                        const classAttr = rect.getAttribute('class') || '';
                        return !classAttr.includes('handle') && !classAttr.includes('bar-progress');
                    });
                    
                    return fallbackBars.length > 0 ? fallbackBars[0] : null;
                };
                
                // Filtra linhas que n√£o s√£o do grid (grid geralmente tem classes espec√≠ficas ou est√£o em grupos espec√≠ficos)
                allRows.forEach(function(row) {
                    const rowClass = row.getAttribute('class') || '';
                    const rowId = row.getAttribute('id') || '';
                    
                    // Ignora linhas de grid, eixos, etc.
                    if (rowClass.includes('grid') || rowClass.includes('axis') || 
                        rowId.includes('grid') || rowId.includes('axis')) {
                        return;
                    }
                    
                    const rects = row.querySelectorAll('rect');
                    const progressBars = Array.from(rects).filter(rect => isProgressBar(rect));
                    
                    if (progressBars.length > 0) {
                        // Ordena as barras da linha por X (da esquerda para direita)
                        // A primeira barra √© geralmente a barra principal
                        const sortedBarsInRow = progressBars.sort(function(a, b) {
                            const xA = parseFloat(a.getAttribute('x') || 0);
                            const xB = parseFloat(b.getAttribute('x') || 0);
                            return xA - xB;
                        });
                        
                        // Pega a primeira barra (barra principal)
                        const mainBar = sortedBarsInRow[0];
                        const y = parseFloat(mainBar.getAttribute('y') || 0);
                        
                        // S√≥ adiciona se a posi√ß√£o Y for v√°lida (n√£o √© linha de grid no topo)
                        if (y > 50) { // Grid geralmente est√° em Y < 50
                            rowsWithBars.push({
                                row: row,
                                bar: mainBar,
                                y: y,
                                allBars: sortedBarsInRow
                            });
                        }
                    }
                });
                
                // Ordena as linhas por Y (de cima para baixo)
                rowsWithBars.sort(function(a, b) {
                    return a.y - b.y;
                });
                
                // FASE 2: REFATORA√á√ÉO - Usar dados do backend diretamente
                // Estrat√©gia: Iterar pelos itens do timelineData e encontrar suas barras no SVG
                // Usa o ID do item para mapear diretamente, sem inferir por nome
                
                console.log('=== APLICANDO CORES USANDO DADOS DO BACKEND ===');
                console.log('Total de itens no timelineData:', timelineData.length);
                console.log('Total de linhas com barras encontradas:', rowsWithBars.length);
                console.log('Primeiros 10 itens:');
                timelineData.slice(0, 10).forEach(function(item, idx) {
                    console.log('  [' + idx + '] ID:', item.id, 'Nome:', item.name.trim(), 'Tipo:', item.custom_class);
                });
                
                // Debug: Verificar estrutura do frappe-gantt
                if (typeof gantt !== 'undefined' && gantt.tasks) {
                    console.log('Gantt tasks dispon√≠veis:', gantt.tasks.length);
                    console.log('Primeiros 3 tasks do gantt:');
                    gantt.tasks.slice(0, 3).forEach(function(task, idx) {
                        console.log('  Task', idx, '- _id:', task._id, 'id:', task.id, 'name:', task.name);
                    });
                }
                
                let coloredCount = 0;
                let skippedCount = 0;
                
                // Itera pelos itens do timelineData na ordem correta
                // Para cada item, encontra suas barras no SVG e aplica cores baseado no custom_class
                timelineData.forEach(function(item, itemIndex) {
                    if (!item || !item.custom_class) {
                        skippedCount++;
                        return;
                    }
                    
                    const itemColors = colors[item.custom_class];
                    if (!itemColors) {
                        skippedCount++;
                        console.warn('‚ö† Item sem cor definida:', item.name, 'custom_class:', item.custom_class);
                        return;
                    }
                    
                    // M√öLTIPLOS M√âTODOS DE BUSCA POR ID
                    // Tenta v√°rios m√©todos para encontrar as barras correspondentes ao item
                    // PRIORIDADE: data-id primeiro (o frappe-gantt usa data-id nos grupos bar-wrapper)
                    let barsFound = [];
                    
                    // M√©todo 1: Buscar grupos SVG por data-id exato (PRIORIDADE - frappe-gantt usa isso!)
                    const groupByDataId = svg.querySelector('g[data-id="' + item.id + '"]');
                    if (groupByDataId) {
                        // FASE 5: Usa getMainBarFromGroup para identificar barra principal
                        const mainBar = getMainBarFromGroup(groupByDataId);
                        if (mainBar) {
                            barsFound = [mainBar]; // Apenas a barra principal
                            if (itemIndex < 5) {
                                console.log('  ‚úì Encontrado via data-id exato no grupo:', item.id, '- Barra principal identificada');
                            }
                        } else {
                            // Fallback: usa todas as barras de progresso
                            const rects = groupByDataId.querySelectorAll('rect');
                            barsFound = Array.from(rects).filter(rect => isProgressBar(rect));
                            if (barsFound.length > 0 && itemIndex < 5) {
                                console.log('  ‚úì Encontrado via data-id exato no grupo:', item.id, '-', barsFound.length, 'barras (fallback)');
                            }
                        }
                    }
                    
                    // M√©todo 2: Buscar grupos SVG por data-id parcial
                    if (barsFound.length === 0) {
                        const groupsByDataIdPartial = svg.querySelectorAll('g[data-id*="' + item.id + '"]');
                        if (groupsByDataIdPartial.length > 0) {
                            // Encontra a melhor barra entre todos os grupos (n√£o adiciona m√∫ltiplas)
                            let bestBar = null;
                            let bestBarY = Infinity;
                            
                            groupsByDataIdPartial.forEach(function(group) {
                                const mainBar = getMainBarFromGroup(group);
                                if (mainBar && isBarVisible(mainBar)) {
                                    const barY = parseFloat(mainBar.getAttribute('y') || Infinity);
                                    // Escolhe a barra mais pr√≥xima do topo (menor Y) que est√° vis√≠vel
                                    if (barY < bestBarY) {
                                        bestBar = mainBar;
                                        bestBarY = barY;
                                    }
                                }
                            });
                            
                            if (bestBar) {
                                barsFound = [bestBar]; // Apenas uma barra principal
                                if (itemIndex < 5) {
                                    console.log('  ‚úì Encontrado via data-id parcial:', item.id, '- Barra principal vis√≠vel identificada');
                                }
                            } else if (groupsByDataIdPartial.length > 0 && itemIndex < 5) {
                                console.warn('  ‚ö† Encontrado grupo mas nenhuma barra vis√≠vel para:', item.id);
                            }
                        }
                    }
                    
                    // M√©todo 3: Buscar grupos SVG por ID exato
                    if (barsFound.length === 0) {
                        const groupById = svg.querySelector('g[id="' + item.id + '"]');
                        if (groupById) {
                            const mainBar = getMainBarFromGroup(groupById);
                            if (mainBar) {
                                barsFound = [mainBar];
                            } else {
                                const rects = groupById.querySelectorAll('rect');
                                barsFound = Array.from(rects).filter(rect => isProgressBar(rect));
                            }
                        }
                    }
                    
                    // M√©todo 5: Buscar grupos SVG por data-task-id exato
                    if (barsFound.length === 0) {
                        const groupByDataTaskId = svg.querySelector('g[data-task-id="' + item.id + '"]');
                        if (groupByDataTaskId) {
                            const mainBar = getMainBarFromGroup(groupByDataTaskId);
                            if (mainBar) {
                                barsFound = [mainBar];
                            } else {
                                const rects = groupByDataTaskId.querySelectorAll('rect');
                                barsFound = Array.from(rects).filter(rect => isProgressBar(rect));
                            }
                        }
                    }
                    
                    // M√©todo 6: Buscar grupos SVG por ID parcial (contains)
                    if (barsFound.length === 0) {
                        const groupsByIdPartial = svg.querySelectorAll('g[id*="' + item.id + '"]');
                        if (groupsByIdPartial.length > 0) {
                            groupsByIdPartial.forEach(function(group) {
                                const mainBar = getMainBarFromGroup(group);
                                if (mainBar) {
                                    barsFound.push(mainBar);
                                } else {
                                    const rects = group.querySelectorAll('rect');
                                    const progressBars = Array.from(rects).filter(rect => isProgressBar(rect));
                                    barsFound = barsFound.concat(progressBars);
                                }
                            });
                        }
                    }
                    
                    // M√©todo 7: Buscar grupos SVG por data-task-id parcial
                    if (barsFound.length === 0) {
                        const groupsByDataTaskIdPartial = svg.querySelectorAll('g[data-task-id*="' + item.id + '"]');
                        if (groupsByDataTaskIdPartial.length > 0) {
                            groupsByDataTaskIdPartial.forEach(function(group) {
                                const mainBar = getMainBarFromGroup(group);
                                if (mainBar) {
                                    barsFound.push(mainBar);
                                } else {
                                    const rects = group.querySelectorAll('rect');
                                    const progressBars = Array.from(rects).filter(rect => isProgressBar(rect));
                                    barsFound = barsFound.concat(progressBars);
                                }
                            });
                        }
                    }
                    
                    // M√©todo 7: Buscar barras diretamente por data-item-id (barras j√° marcadas)
                    if (barsFound.length === 0) {
                        const existingBars = svg.querySelectorAll('rect[data-item-id="' + item.id + '"]');
                        if (existingBars.length > 0) {
                            barsFound = Array.from(existingBars).filter(rect => isProgressBar(rect));
                        }
                    }
                    
                    // M√©todo 8: Usar objeto gantt.tasks (se dispon√≠vel)
                    if (barsFound.length === 0 && typeof gantt !== 'undefined' && gantt.tasks) {
                        const task = gantt.tasks.find(function(t) {
                            return (t._id === item.id) || (t.id === item.id) || (String(t._id) === String(item.id)) || (String(t.id) === String(item.id));
                        });
                        if (task) {
                            // O frappe-gantt pode armazenar refer√™ncia ao elemento bar em diferentes propriedades
                            const barElement = task.$bar || task.bar_wrapper || task.$bar_wrapper;
                            if (barElement) {
                                if (isProgressBar(barElement)) {
                                    barsFound = [barElement];
                                } else {
                                    // Pode ser um grupo, buscar rects dentro
                                    const rects = barElement.querySelectorAll('rect');
                                    const progressBars = Array.from(rects).filter(rect => isProgressBar(rect));
                                    barsFound = progressBars;
                                }
                            }
                            
                            // Se ainda n√£o encontrou, tenta buscar pelo ID do task no SVG
                            if (barsFound.length === 0) {
                                const taskId = task._id || task.id;
                                const groupByTaskId = svg.querySelector('g[data-id="' + taskId + '"]') ||
                                                     svg.querySelector('g[data-task-id="' + taskId + '"]') || 
                                                     svg.querySelector('g[id="' + taskId + '"]');
                                if (groupByTaskId) {
                                    const mainBar = getMainBarFromGroup(groupByTaskId);
                                    if (mainBar) {
                                        barsFound = [mainBar];
                                    } else {
                                        const rects = groupByTaskId.querySelectorAll('rect');
                                        barsFound = Array.from(rects).filter(rect => isProgressBar(rect));
                                    }
                                }
                            }
                        }
                    }
                    
                    // M√©todo 9: Mapeamento por √≠ndice com valida√ß√£o
                    // Tenta mapear pela posi√ß√£o, mas valida se faz sentido
                    if (barsFound.length === 0) {
                        // Primeiro tenta √≠ndice exato
                        if (itemIndex < rowsWithBars.length) {
                            const rowData = rowsWithBars[itemIndex];
                            if (rowData) {
                                const allRectsInRow = rowData.row.querySelectorAll('rect');
                                const progressBars = Array.from(allRectsInRow).filter(rect => isProgressBar(rect));
                                if (progressBars.length > 0) {
                                    barsFound = progressBars;
                                } else if (rowData.allBars.length > 0) {
                                    barsFound = rowData.allBars;
                                }
                            }
                        }
                        
                        // Se n√£o encontrou no √≠ndice exato, tenta √≠ndices pr√≥ximos (¬±2)
                        if (barsFound.length === 0) {
                            for (let offset = 1; offset <= 2; offset++) {
                                // Tenta √≠ndice anterior
                                if (itemIndex - offset >= 0 && itemIndex - offset < rowsWithBars.length) {
                                    const rowData = rowsWithBars[itemIndex - offset];
                                    if (rowData) {
                                        const allRectsInRow = rowData.row.querySelectorAll('rect');
                                        const progressBars = Array.from(allRectsInRow).filter(rect => isProgressBar(rect));
                                        if (progressBars.length > 0) {
                                            barsFound = progressBars;
                                            break;
                                        }
                                    }
                                }
                                
                                // Tenta √≠ndice posterior
                                if (barsFound.length === 0 && itemIndex + offset < rowsWithBars.length) {
                                    const rowData = rowsWithBars[itemIndex + offset];
                                    if (rowData) {
                                        const allRectsInRow = rowData.row.querySelectorAll('rect');
                                        const progressBars = Array.from(allRectsInRow).filter(rect => isProgressBar(rect));
                                        if (progressBars.length > 0) {
                                            barsFound = progressBars;
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    
                    // M√©todo 10: Buscar por texto pr√≥ximo (√∫ltimo recurso)
                    // Procura grupos que contenham texto similar ao nome do item
                    if (barsFound.length === 0) {
                        const itemNameNormalized = item.name.trim().toLowerCase();
                        const allGroups = Array.from(svg.querySelectorAll('g'));
                        allGroups.forEach(function(group) {
                            const texts = group.querySelectorAll('text');
                            texts.forEach(function(text) {
                                const textContent = (text.textContent || '').trim().toLowerCase();
                                // Se o texto cont√©m parte significativa do nome do item
                                if (textContent.length > 3 && itemNameNormalized.length > 3) {
                                    const textWords = textContent.split(/\s+/).filter(w => w.length > 2);
                                    const itemWords = itemNameNormalized.split(/\s+/).filter(w => w.length > 2);
                                    const matchingWords = textWords.filter(w => itemWords.some(iw => iw.includes(w) || w.includes(iw)));
                                    
                                    // Se pelo menos 2 palavras correspondem, considera um match
                                    if (matchingWords.length >= 2 || (matchingWords.length >= 1 && textContent.length > 10)) {
                                        const rects = group.querySelectorAll('rect');
                                        const progressBars = Array.from(rects).filter(rect => isProgressBar(rect));
                                        if (progressBars.length > 0) {
                                            barsFound = barsFound.concat(progressBars);
                                        }
                                    }
                                }
                            });
                        });
                    }
                    
                    // FASE 3: Aplica cores diretamente pelo custom_class do backend
                    // CR√çTICO: Verifica se a barra j√° foi colorida por outro item antes de aplicar
                    if (barsFound.length > 0) {
                        // Filtra barras que j√° foram coloridas por outro item
                        const uncoloredBars = barsFound.filter(function(bar) {
                            const existingItemId = bar.getAttribute('data-item-id');
                            // Se j√° tem data-item-id de outro item, n√£o deve ser reutilizada
                            return !existingItemId || existingItemId === item.id;
                        });
                        
                        // Se todas as barras j√° foram usadas, tenta encontrar uma barra nova
                        let barsToColor = uncoloredBars.length > 0 ? uncoloredBars : [];
                        
                        // Se ainda n√£o encontrou, tenta barras vis√≠veis
                        if (barsToColor.length === 0) {
                            const visibleBars = barsFound.filter(bar => isBarVisible(bar));
                            barsToColor = visibleBars.length > 0 ? visibleBars : barsFound.slice(0, 1);
                        }
                        
                        // Filtra novamente para garantir que n√£o est√° reutilizando
                        barsToColor = barsToColor.filter(function(bar) {
                            const existingItemId = bar.getAttribute('data-item-id');
                            return !existingItemId || existingItemId === item.id;
                        });
                        
                        if (barsToColor.length > 0) {
                            // Aplica cores apenas na primeira barra (barra principal) que n√£o foi usada
                            const mainBar = barsToColor[0];
                            
                            // Verifica√ß√£o final: se a barra j√° tem data-item-id de outro item, pula
                            const finalItemId = mainBar.getAttribute('data-item-id');
                            if (finalItemId && finalItemId !== item.id) {
                                if (itemIndex < 10) {
                                    console.warn('  ‚ö† Barra j√° usada por outro item:', finalItemId, '- Pulando item:', item.id);
                                }
                                skippedCount++;
                                return; // Pula este item
                            }
                            
                            // Aplica cores apenas na barra principal (n√£o em todas)
                            [mainBar].forEach(function(barElement, barIdx) {
                            // FASE 2: LOGS DETALHADOS DURANTE APLICA√á√ÉO DE CORES
                            const beforeX = parseFloat(barElement.getAttribute('x') || 0);
                            const beforeY = parseFloat(barElement.getAttribute('y') || 0);
                            const beforeWidth = parseFloat(barElement.getAttribute('width') || 0);
                            const beforeHeight = parseFloat(barElement.getAttribute('height') || 0);
                            const beforeFill = barElement.getAttribute('fill') || '';
                            const beforeStroke = barElement.getAttribute('stroke') || '';
                            const beforeClass = barElement.getAttribute('class') || '';
                            const beforeDataItemId = barElement.getAttribute('data-item-id') || '';
                            
                            // Log detalhado para primeiros itens
                            if (itemIndex < 10) {
                                console.log(`  [DEBUG] Aplicando cor na barra principal do item ${itemIndex}:`);
                                console.log('    Posi√ß√£o:', `x=${beforeX}, y=${beforeY}, w=${beforeWidth}, h=${beforeHeight}`);
                                console.log('    Antes - fill:', beforeFill, 'stroke:', beforeStroke);
                                console.log('    Antes - class:', beforeClass || '(vazio)');
                                console.log('    Antes - data-item-id:', beforeDataItemId || '(vazio)');
                                console.log('    √â barra de progresso?', isProgressBar(barElement));
                                
                                // Verifica visibilidade
                                const computedBefore = window.getComputedStyle(barElement);
                                console.log('    Computed antes - fill:', computedBefore.fill, 'stroke:', computedBefore.stroke);
                                console.log('    Visibilidade:', computedBefore.visibility, 'display:', computedBefore.display);
                            }
                            
                            // Salva a cor original
                            if (!barElement.hasAttribute('data-original-fill')) {
                                const currentFill = barElement.getAttribute('fill') || '#ddd';
                                barElement.setAttribute('data-original-fill', currentFill);
                            }
                            
                            // FASE 6: APLICA√á√ÉO ROBUSTA COM M√öLTIPLAS CAMADAS
                            // Usa m√∫ltiplos m√©todos para garantir persist√™ncia m√°xima
                            
                            // CAMADA 1: Atributos de identifica√ß√£o (PRIMEIRO - antes de qualquer estilo)
                            barElement.setAttribute('data-item-id', item.id);
                            barElement.setAttribute('data-custom-color', 'true');
                            barElement.setAttribute('data-item-type', item.custom_class);
                            
                            // CAMADA 2: Atributos SVG inline (mais b√°sico, funciona sempre)
                            barElement.setAttribute('fill', itemColors.fill);
                            barElement.setAttribute('stroke', itemColors.stroke);
                            barElement.setAttribute('stroke-width', itemColors.strokeWidth);
                            
                            // CAMADA 3: Style inline com !important (sobrescreve CSS)
                            barElement.style.setProperty('fill', itemColors.fill, 'important');
                            barElement.style.setProperty('stroke', itemColors.stroke, 'important');
                            barElement.style.setProperty('stroke-width', itemColors.strokeWidth, 'important');
                            
                            // CAMADA 4: Remove classes conflitantes do frappe-gantt
                            const currentClass = barElement.getAttribute('class') || '';
                            if (currentClass) {
                                const newClass = currentClass.split(' ').filter(c => 
                                    !c.includes('bar-fill') && !c.includes('bar-stroke') && 
                                    !c.includes('gantt-bar') && !c.includes('progress-bar')
                                ).join(' ');
                                if (newClass !== currentClass) {
                                    barElement.setAttribute('class', newClass);
                                }
                            }
                            
                            // CAMADA 5: Adiciona classes CSS customizadas (para seletores CSS)
                            barElement.classList.add('gantt-custom-colored');
                            barElement.classList.add('gantt-' + item.custom_class.replace('gantt-', ''));
                            barElement.classList.add('gantt-item-' + item.id.replace(/[^a-zA-Z0-9]/g, '-'));
                            
                            // CAMADA 6: Reaplica atributos ap√≥s todas as modifica√ß√µes (garantia extra)
                            barElement.setAttribute('data-item-id', item.id);
                            barElement.setAttribute('fill', itemColors.fill);
                            barElement.setAttribute('stroke', itemColors.stroke);
                            
                            // CAMADA 7: For√ßa atualiza√ß√£o visual (trigger reflow)
                            const originalDisplay = barElement.style.display;
                            barElement.style.display = 'none';
                            barElement.offsetHeight; // Trigger reflow
                            barElement.style.display = originalDisplay || '';
                            
                            // CAMADA 8: Reaplica estilos ap√≥s reflow (garantia final)
                            barElement.style.setProperty('fill', itemColors.fill, 'important');
                            barElement.style.setProperty('stroke', itemColors.stroke, 'important');
                            
                            // FASE 2: VERIFICA√á√ÉO IMEDIATA AP√ìS APLICA√á√ÉO
                            if (itemIndex < 10) {
                                const afterFill = barElement.getAttribute('fill') || '';
                                const afterStroke = barElement.getAttribute('stroke') || '';
                                const afterDataItemId = barElement.getAttribute('data-item-id') || '';
                                const computedAfter = window.getComputedStyle(barElement);
                                
                                console.log('    Depois - fill:', afterFill, 'stroke:', afterStroke);
                                console.log('    Depois - data-item-id:', afterDataItemId || '(vazio)');
                                console.log('    Computed depois - fill:', computedAfter.fill, 'stroke:', computedAfter.stroke);
                                
                                // Verifica se a cor foi aplicada corretamente
                                if (afterFill !== itemColors.fill && computedAfter.fill !== itemColors.fill) {
                                    console.warn('    ‚ö† PROBLEMA: Cor n√£o foi aplicada! Esperado:', itemColors.fill, 'Atual fill:', afterFill, 'Computed:', computedAfter.fill);
                                } else {
                                    console.log('    ‚úì Cor aplicada com sucesso');
                                }
                                
                                // Verifica se data-item-id foi aplicado
                                if (afterDataItemId !== item.id) {
                                    console.warn('    ‚ö† PROBLEMA: data-item-id n√£o foi aplicado! Esperado:', item.id, 'Atual:', afterDataItemId);
                                } else {
                                    console.log('    ‚úì data-item-id aplicado com sucesso');
                                }
                            }
                            
                            // 7. Cursor pointer se tiver URL
                            if (item.url) {
                                barElement.style.cursor = 'pointer';
                                barElement.setAttribute('title', 'Clique para ver detalhes: ' + item.name.trim());
                            }
                        });
                        
                            coloredCount++;
                            
                            if (itemIndex < 20 || barsToColor.length === 0) {
                                const barY = mainBar ? parseFloat(mainBar.getAttribute('y') || 0) : 0;
                                const isVisible = mainBar ? isBarVisible(mainBar) : false;
                                console.log('‚úì Cor aplicada - Item', itemIndex, ':', item.name.trim(), '(', item.custom_class, ') ->', itemColors.fill, '- 1 barra principal, Y:', barY, 'Vis√≠vel:', isVisible);
                            }
                        } else {
                            skippedCount++;
                            if (itemIndex < 20) {
                                console.warn('‚ö† Todas as barras encontradas j√° foram usadas por outros itens para:', item.name.trim(), '(ID:', item.id, ', √≠ndice', itemIndex, ', tipo:', item.custom_class + ')');
                            }
                        }
                    } else {
                        skippedCount++;
                        console.warn('‚ö† Nenhuma barra encontrada para item:', item.name.trim(), '(ID:', item.id, ', √≠ndice', itemIndex, ', tipo:', item.custom_class + ')');
                        
                        // Debug adicional para itens n√£o mapeados
                        if (skippedCount <= 15) {
                            console.warn('  Tentando m√©todos alternativos...');
                            
                            // Tenta encontrar qualquer barra pr√≥xima por posi√ß√£o
                            if (itemIndex < rowsWithBars.length) {
                                const nearbyRow = rowsWithBars[itemIndex];
                                console.warn('  Linha pr√≥xima encontrada na posi√ß√£o', itemIndex, '- Y:', nearbyRow.y);
                                const nearbyBars = nearbyRow.row.querySelectorAll('rect');
                                console.warn('  Total de rects na linha:', nearbyBars.length);
                                
                                // Tenta aplicar cor mesmo sem match perfeito (√∫ltimo recurso)
                                const progressBars = Array.from(nearbyBars).filter(rect => isProgressBar(rect));
                                if (progressBars.length > 0) {
                                    console.warn('  Aplicando cor por proximidade (fallback)...');
                                    progressBars.forEach(function(barElement) {
                                        barElement.setAttribute('fill', itemColors.fill);
                                        barElement.style.setProperty('fill', itemColors.fill, 'important');
                                        barElement.setAttribute('stroke', itemColors.stroke);
                                        barElement.style.setProperty('stroke', itemColors.stroke, 'important');
                                        barElement.setAttribute('stroke-width', itemColors.strokeWidth);
                                        barElement.style.setProperty('stroke-width', itemColors.strokeWidth, 'important');
                                        barElement.setAttribute('data-item-id', item.id);
                                        barElement.setAttribute('data-custom-color', 'true');
                                    });
                                    coloredCount++;
                                    skippedCount--; // N√£o conta como skipped se aplicou por proximidade
                                }
                            }
                        }
                    }
                });
                
                console.log('=== RESUMO ===');
                console.log('Itens processados:', coloredCount, 'de', timelineData.length);
                console.log('Itens n√£o mapeados:', skippedCount);
                
                // Verifica√ß√£o final: Se muitos itens n√£o foram mapeados, tenta mapeamento for√ßado por √≠ndice
                if (skippedCount > timelineData.length * 0.1) {
                    console.warn('‚ö† Muitos itens n√£o mapeados (', skippedCount, 'de', timelineData.length, '). Tentando mapeamento for√ßado por √≠ndice...');
                    
                    // Mapeia todos os itens restantes por √≠ndice diretamente
                    timelineData.forEach(function(item, itemIndex) {
                        if (!item || !item.custom_class) return;
                        
                        const itemColors = colors[item.custom_class];
                        if (!itemColors) return;
                        
                        // Verifica se j√° foi colorido
                        const existingBars = svg.querySelectorAll('rect[data-item-id="' + item.id + '"]');
                        if (existingBars.length > 0) return; // J√° foi colorido
                        
                        // Tenta mapear por √≠ndice
                        if (itemIndex < rowsWithBars.length) {
                            const rowData = rowsWithBars[itemIndex];
                            if (rowData) {
                                const allRectsInRow = rowData.row.querySelectorAll('rect');
                                const progressBars = Array.from(allRectsInRow).filter(rect => isProgressBar(rect));
                                
                                if (progressBars.length > 0) {
                                    progressBars.forEach(function(barElement) {
                                        // Verifica se j√° tem data-item-id de outro item
                                        const existingItemId = barElement.getAttribute('data-item-id');
                                        if (!existingItemId) {
                                            // Aplica cor
                                            barElement.setAttribute('fill', itemColors.fill);
                                            barElement.style.setProperty('fill', itemColors.fill, 'important');
                                            barElement.setAttribute('stroke', itemColors.stroke);
                                            barElement.style.setProperty('stroke', itemColors.stroke, 'important');
                                            barElement.setAttribute('stroke-width', itemColors.strokeWidth);
                                            barElement.style.setProperty('stroke-width', itemColors.strokeWidth, 'important');
                                            barElement.setAttribute('data-item-id', item.id);
                                            barElement.setAttribute('data-custom-color', 'true');
                                            coloredCount++;
                                        }
                                    });
                                }
                            }
                        }
                    });
                    
                    console.log('Ap√≥s mapeamento for√ßado:', coloredCount, 'itens coloridos');
                }
                
                // Atualiza CSS din√¢mico para garantir persist√™ncia
                updateDynamicCSS(timelineData);
                
                // FASE 4: VERIFICA√á√ÉO DE COMPUTED STYLES E ESPECIFICIDADE CSS
                // Verifica se o CSS din√¢mico est√° funcionando corretamente
                setTimeout(function() {
                    console.log('=== VERIFICA√á√ÉO DE CSS E COMPUTED STYLES ===');
                    
                    // Verifica alguns itens para testar especificidade
                    timelineData.slice(0, 5).forEach(function(item) {
                        if (!item || !item.custom_class) return;
                        
                        const itemColors = colors[item.custom_class];
                        if (!itemColors) return;
                        
                        // Encontra barras com data-item-id
                        const bars = svg.querySelectorAll('rect[data-item-id="' + item.id + '"]');
                        
                        if (bars.length > 0) {
                            bars.forEach(function(bar, barIdx) {
                                if (barIdx === 0) { // Apenas primeira barra de cada item
                                    const computedStyle = window.getComputedStyle(bar);
                                    const attrFill = bar.getAttribute('fill') || '';
                                    const styleFill = bar.style.fill || '';
                                    
                                    console.log(`Item: ${item.name.trim()} (${item.custom_class})`);
                                    console.log('  Attr fill:', attrFill || '(vazio)');
                                    console.log('  Style fill:', styleFill || '(vazio)');
                                    console.log('  Computed fill:', computedStyle.fill);
                                    console.log('  Computed stroke:', computedStyle.stroke);
                                    
                                    // Verifica especificidade de seletores CSS
                                    const testSelectors = [
                                        `rect[data-item-id="${item.id}"]`,
                                        `.gantt-custom-colored[data-item-id="${item.id}"]`,
                                        `g[data-id="${item.id}"] rect`
                                    ];
                                    
                                    testSelectors.forEach(function(selector) {
                                        const matchingElements = svg.querySelectorAll(selector);
                                        if (matchingElements.length > 0) {
                                            console.log(`  Seletor "${selector}": ${matchingElements.length} elemento(s) encontrado(s)`);
                                        }
                                    });
                                }
                            });
                        }
                    });
                }, 1000);
                
                // FASE 2: VALIDA√á√ÉO VISUAL COM COMPUTED STYLES
                // Verifica se as cores aplicadas correspondem √†s esperadas usando computed styles
                setTimeout(function() {
                    let validationErrors = 0;
                    let validatedItems = 0;
                    let validationDetails = [];
                    
                    // Define as cores fixas para valida√ß√£o
                    const colorsForValidation = {
                        'gantt-project': { fill: '#1a73e8', stroke: '#1a73e8', strokeWidth: '2' },
                        'gantt-macro': { fill: '#34a853', stroke: '#34a853', strokeWidth: '1.5' },
                        'gantt-stage': { fill: '#fbbc04', stroke: '#fbbc04', strokeWidth: '1' },
                        'gantt-task': { fill: '#9aa0a6', stroke: '#9aa0a6', strokeWidth: '0.5' }
                    };
                    
                    console.log('=== VALIDA√á√ÉO DE CORES COM COMPUTED STYLES ===');
                    
                    // Valida cada item do timelineData
                    timelineData.forEach(function(item, itemIndex) {
                        if (!item || !item.custom_class) return;
                        
                        const expectedColors = colorsForValidation[item.custom_class];
                        if (!expectedColors) return;
                        
                        // Encontra todas as barras com data-item-id deste item
                        const allBars = svg.querySelectorAll('rect[data-item-id="' + item.id + '"]');
                        
                        if (allBars.length > 0) {
                            validatedItems++;
                            allBars.forEach(function(bar) {
                                // Verifica atributo fill
                                const attrFill = bar.getAttribute('fill') || '';
                                // Verifica computed style fill (mais confi√°vel)
                                const computedFill = window.getComputedStyle(bar).fill;
                                // Converte RGB para hex se necess√°rio
                                let computedFillHex = computedFill;
                                if (computedFill.startsWith('rgb')) {
                                    const rgb = computedFill.match(/\d+/g);
                                    if (rgb && rgb.length >= 3) {
                                        computedFillHex = '#' + rgb.map(x => {
                                            const hex = parseInt(x).toString(16);
                                            return hex.length === 1 ? '0' + hex : hex;
                                        }).join('');
                                    }
                                }
                                
                                // Verifica se a cor corresponde (toler√¢ncia para varia√ß√µes de RGB)
                                const fillMatches = attrFill === expectedColors.fill || 
                                                   computedFillHex.toLowerCase() === expectedColors.fill.toLowerCase() ||
                                                   computedFill === expectedColors.fill;
                                
                                if (!fillMatches && computedFill !== 'none' && computedFill !== '' && computedFill !== 'transparent') {
                                    validationErrors++;
                                    const detail = {
                                        item: item.name.trim(),
                                        expected: expectedColors.fill,
                                        attrFill: attrFill,
                                        computedFill: computedFill,
                                        computedHex: computedFillHex,
                                        type: item.custom_class
                                    };
                                    validationDetails.push(detail);
                                    
                                    if (validationErrors <= 10) {
                                        console.warn('‚ö† Valida√ß√£o:', item.name.trim(), '- Esperado:', expectedColors.fill, 
                                                   'Attr:', attrFill || '(vazio)', 
                                                   'Computed:', computedFill, 
                                                   'Computed Hex:', computedFillHex,
                                                   'Tipo:', item.custom_class);
                                    }
                                } else if (itemIndex < 10) {
                                    console.log('‚úì Valida√ß√£o OK:', item.name.trim(), '- Fill:', computedFill, 'Tipo:', item.custom_class);
                                }
                            });
                        } else if (itemIndex < 20) {
                            // Log apenas para os primeiros itens n√£o mapeados
                            console.warn('‚ö† Valida√ß√£o: Nenhuma barra encontrada para', item.name.trim(), '(√≠ndice', itemIndex + ')');
                            
                            // Tenta encontrar barras sem data-item-id mas que podem ter sido coloridas
                            const groupByDataId = svg.querySelector('g[data-id="' + item.id + '"]');
                            if (groupByDataId) {
                                const rectsInGroup = groupByDataId.querySelectorAll('rect');
                                console.warn('  Mas encontrado grupo com data-id:', item.id, '-', rectsInGroup.length, 'rects dentro');
                            }
                        }
                    });
                    
                    console.log('=== RESUMO DA VALIDA√á√ÉO ===');
                    console.log('Itens validados:', validatedItems, 'de', timelineData.length);
                    console.log('Erros encontrados:', validationErrors);
                    
                    if (validationErrors > 0) {
                        console.warn('‚ö† Valida√ß√£o visual:', validationErrors, 'barras com cores que n√£o correspondem ao esperado');
                        console.log('Detalhes dos erros:', validationDetails.slice(0, 5));
                    } else {
                        console.log('‚úì Valida√ß√£o visual: Todas as cores aplicadas correspondem ao esperado');
                    }
                    
                    // Libera flag ap√≥s valida√ß√£o
                    isApplyingColors = false;
                }, 500); // Aumentado para 500ms para dar tempo das cores serem aplicadas
            };
            
            // Torna applyColors acess√≠vel globalmente
            window.applyGanttColors = applyColors;
            
            // Aplica cores ap√≥s o Gantt renderizar (m√°ximo 5 tentativas)
            const applyColorsWithRetry = function(attempt) {
                if (attempt > 5) {
                    console.warn('M√°ximo de tentativas de aplicar cores atingido');
                    return;
                }
                
                const container = document.getElementById('gantt-container');
                if (!container) {
                    setTimeout(function() {
                        applyColorsWithRetry(attempt + 1);
                    }, 500);
                    return;
                }
                
                const svg = container.querySelector('svg');
                if (!svg) {
                    console.log('Tentativa', attempt, '- SVG ainda n√£o renderizado, tentando novamente...');
                    setTimeout(function() {
                        applyColorsWithRetry(attempt + 1);
                    }, 500);
                    return;
                }
                
                // Verifica se h√° barras de progresso (n√£o apenas qualquer rect)
                const allRects = svg.querySelectorAll('rect');
                let progressBars = 0;
                allRects.forEach(function(rect) {
                    const height = parseFloat(rect.getAttribute('height') || 0);
                    const width = parseFloat(rect.getAttribute('width') || 0);
                    if (height > 8 && height < 60 && width > height) {
                        progressBars++;
                    }
                });
                
                if (progressBars === 0) {
                    console.log('Tentativa', attempt, '- Barras ainda n√£o renderizadas, tentando novamente...');
                    setTimeout(function() {
                        applyColorsWithRetry(attempt + 1);
                    }, 500);
                } else {
                    console.log('Barras encontradas na tentativa', attempt, '(', progressBars, 'barras) - Aplicando cores...');
                    // Aplica cores apenas uma vez quando encontrar as barras
                    applyColors();
                }
            };
            
            // Inicia as tentativas ap√≥s um pequeno delay
            setTimeout(function() {
                applyColorsWithRetry(1);
            }, 500);
            
            // SOLU√á√ÉO MELHORADA: Criar cabe√ßalho fixo usando position: sticky
            // Abordagem robusta: clonar SVG e usar viewBox + overflow para mostrar apenas cabe√ßalho
            let stickyHeaderElement = null;
            let scrollSyncHandler = null;
            
            const setupStickyHeader = function() {
                console.log('[setupStickyHeader] Iniciando cria√ß√£o do cabe√ßalho fixo...');
                
                // Remove cabe√ßalho anterior se existir
                if (stickyHeaderElement) {
                    console.log('[setupStickyHeader] Removendo cabe√ßalho anterior...');
                    if (scrollSyncHandler) {
                        const ganttWrapper = document.getElementById('gantt-wrapper');
                        if (ganttWrapper) {
                            ganttWrapper.removeEventListener('scroll', scrollSyncHandler);
                        }
                    }
                    stickyHeaderElement.remove();
                    stickyHeaderElement = null;
                    scrollSyncHandler = null;
                }
                
                const container = document.getElementById('gantt-container');
                if (!container) {
                    console.warn('[setupStickyHeader] ‚ùå Container n√£o encontrado');
                    return false;
                }
                
                const svg = container.querySelector('svg');
                if (!svg) {
                    console.warn('[setupStickyHeader] ‚ùå SVG n√£o encontrado no container');
                    console.log('[setupStickyHeader] Container:', container);
                    console.log('[setupStickyHeader] Elementos no container:', container.children);
                    return false;
                }
                console.log('[setupStickyHeader] ‚úì SVG encontrado');
                
                // Detecta altura do cabe√ßalho dinamicamente (pode variar por view mode)
                const headerHeight = ganttConfig.header_height || 50;
                console.log('[setupStickyHeader] Altura do cabe√ßalho configurada:', headerHeight);
                
                const ganttWrapper = document.getElementById('gantt-wrapper');
                if (!ganttWrapper) {
                    console.warn('[setupStickyHeader] ‚ùå gantt-wrapper n√£o encontrado');
                    return false;
                }
                console.log('[setupStickyHeader] ‚úì gantt-wrapper encontrado');
                
                const svgParent = svg.parentElement;
                // O frappe-gantt cria um elemento com classe 'gantt-container', n√£o necessariamente com ID
                // Verifica se o parent existe
                if (!svgParent) {
                    console.warn('[setupStickyHeader] ‚ùå Parent do SVG n√£o encontrado');
                    return false;
                }
                
                // Verifica se √© o container correto (pode ter classe ou ID)
                const hasContainerId = svgParent.id === 'gantt-container';
                const hasContainerClass = svgParent.classList && svgParent.classList.contains('gantt-container');
                
                if (!hasContainerId && !hasContainerClass) {
                    console.warn('[setupStickyHeader] ‚ö† Parent n√£o tem ID nem classe gantt-container');
                    console.log('[setupStickyHeader] Parent ID:', svgParent.id, 'Classes:', svgParent.className);
                    // Continua mesmo assim, pois o parent existe e pode ser v√°lido
                }
                
                console.log('[setupStickyHeader] ‚úì Container do SVG encontrado (ID:', hasContainerId, 'Class:', hasContainerClass + ')');
                
                // Verifica se o SVG tem conte√∫do v√°lido
                const svgWidth = parseFloat(svg.getAttribute('width') || svg.getBoundingClientRect().width || 0);
                const svgHeight = parseFloat(svg.getAttribute('height') || svg.getBoundingClientRect().height || 0);
                console.log('[setupStickyHeader] Dimens√µes do SVG - width:', svgWidth, 'height:', svgHeight);
                
                if (svgWidth === 0 || svgHeight === 0) {
                    console.warn('[setupStickyHeader] ‚ùå SVG sem dimens√µes v√°lidas');
                    return false;
                }
                console.log('[setupStickyHeader] ‚úì SVG tem dimens√µes v√°lidas');
                
                // IMPORTANTE: O cabe√ßalho sticky precisa estar dentro do elemento com scroll (#gantt-wrapper)
                // n√£o dentro do container, para que o position: sticky funcione corretamente
                // Cria elemento sticky que cont√©m apenas o cabe√ßalho
                stickyHeaderElement = document.createElement('div');
                stickyHeaderElement.id = 'gantt-sticky-header';
                stickyHeaderElement.className = 'gantt-sticky-header';
                
                // Verifica se o svgParent √© filho direto do ganttWrapper
                // Se n√£o for, insere no in√≠cio do wrapper
                if (svgParent && svgParent.parentElement === ganttWrapper) {
                    // Insere no wrapper (elemento com scroll), antes do container
                    ganttWrapper.insertBefore(stickyHeaderElement, svgParent);
                    console.log('[setupStickyHeader] Cabe√ßalho inserido antes do container');
                } else {
                    // Se o container n√£o for filho direto, insere no in√≠cio do wrapper
                    if (ganttWrapper.firstChild) {
                        ganttWrapper.insertBefore(stickyHeaderElement, ganttWrapper.firstChild);
                    } else {
                        ganttWrapper.appendChild(stickyHeaderElement);
                    }
                    console.log('[setupStickyHeader] Cabe√ßalho inserido no in√≠cio do wrapper (container n√£o √© filho direto)');
                    console.log('[setupStickyHeader] Estrutura: wrapper ->', ganttWrapper.children.length, 'filhos');
                }
                
                // Clona SVG completo
                const headerSVG = svg.cloneNode(true);
                
                // Salva o viewBox original para refer√™ncia
                const originalViewBoxStr = svg.getAttribute('viewBox') || '';
                let originalViewBoxParts = null;
                if (originalViewBoxStr) {
                    originalViewBoxParts = originalViewBoxStr.split(' ').map(parseFloat);
                }
                
                // Ajusta viewBox inicial para mostrar apenas cabe√ßalho
                // CR√çTICO: Textos est√£o em Y=55 (upper-text: meses) e Y=80 (lower-text: datas)
                // Textos tem ~20px de altura, ent√£o precisamos de espa√ßo at√© Y=105 no m√≠nimo
                if (originalViewBoxParts && originalViewBoxParts.length === 4) {
                    // viewBox: x y width height
                    // Come√ßa em Y=0 e vai at√© Y=110 (textos em 55 e 80, fim em ~100, margem at√© 110)
                    // IMPORTANTE: N√£o usar 'slice' no preserveAspectRatio para n√£o cortar
                    headerSVG.setAttribute('viewBox', originalViewBoxParts[0] + ' 0 ' + originalViewBoxParts[2] + ' 110');
                } else {
                    // Se n√£o houver viewBox, cria um baseado nas dimens√µes
                    headerSVG.setAttribute('viewBox', '0 0 ' + svgWidth + ' 110');
                    originalViewBoxParts = [0, 0, svgWidth, svgHeight];
                }
                
                // Configura dimens√µes e estilos do SVG clonado
                // IMPORTANTE: Usa 'none' para manter exatamente as coordenadas sem escala
                headerSVG.setAttribute('height', '110');
                headerSVG.setAttribute('width', svgWidth || '100%');
                // O SVG clonado deve ter a mesma largura do original para alinhamento perfeito
                headerSVG.style.width = svgWidth + 'px';
                headerSVG.style.height = '110px';
                headerSVG.style.display = 'block';
                headerSVG.style.overflow = 'visible'; // MUDADO: visible para n√£o cortar textos
                headerSVG.style.pointerEvents = 'none'; // Evita intera√ß√µes no cabe√ßalho clonado
                // CR√çTICO: 'none' garante que o SVG n√£o seja escalado, mantendo coordenadas originais
                headerSVG.setAttribute('preserveAspectRatio', 'none');
                
                stickyHeaderElement.appendChild(headerSVG);
                
                // Oculta o cabe√ßalho original no SVG para evitar duplica√ß√£o
                // Usa a fun√ß√£o global para garantir que seja reutiliz√°vel
                if (typeof window.hideGanttOriginalHeader === 'function') {
                    window.hideGanttOriginalHeader(svg, headerHeight);
                }
                
                // Debug: verifica se o elemento foi criado corretamente
                console.log('Cabe√ßalho fixo criado:', {
                    element: stickyHeaderElement,
                    parent: stickyHeaderElement.parentElement?.id,
                    position: window.getComputedStyle(stickyHeaderElement).position,
                    zIndex: window.getComputedStyle(stickyHeaderElement).zIndex,
                    top: window.getComputedStyle(stickyHeaderElement).top,
                    visible: window.getComputedStyle(stickyHeaderElement).visibility
                });
                
                // Sincroniza scroll horizontal: move o SVG clonado usando translateX
                // Abordagem mais simples e confi√°vel que ajustar viewBox
                let scrollSyncRaf = null;
                let lastScrollLeft = 0;
                
                // Fun√ß√£o para sincronizar o cabe√ßalho com o scroll horizontal
                // Aceita scrollLeft como par√¢metro para usar o valor exato do evento
                const updateHeaderPosition = function(scrollLeft) {
                    if (stickyHeaderElement && headerSVG) {
                        // Se n√£o foi passado scrollLeft, tenta detectar automaticamente
                        if (scrollLeft === undefined) {
                            scrollLeft = container.scrollLeft;
                        }
                        
                        // Move o SVG do cabe√ßalho usando translateX
                        // Negativo porque quando scrollamos para a direita, o conte√∫do deve mover para a esquerda
                        // IMPORTANTE: Usa transform 3D para melhor performance
                        headerSVG.style.transform = 'translate3d(' + (-scrollLeft) + 'px, 0, 0)';
                        headerSVG.style.webkitTransform = 'translate3d(' + (-scrollLeft) + 'px, 0, 0)';
                        
                        // Debug quando h√° mudan√ßa no scroll
                        if (scrollLeft !== lastScrollLeft) {
                            console.log('[updateHeaderPosition] scrollLeft mudou:', lastScrollLeft, '->', scrollLeft, 'translate3d:', -scrollLeft + 'px, 0, 0');
                            lastScrollLeft = scrollLeft;
                        }
                    }
                };
                
                scrollSyncHandler = function(event) {
                    console.log('[scrollSyncHandler] Evento de scroll detectado!', event.target.id || event.target.className, 'scrollLeft:', event.target.scrollLeft);
                    if (scrollSyncRaf) {
                        cancelAnimationFrame(scrollSyncRaf);
                    }
                    // CR√çTICO: Passa o scrollLeft do elemento que est√° realmente scrollando
                    const scrollLeft = event.target.scrollLeft;
                    scrollSyncRaf = requestAnimationFrame(function() {
                        updateHeaderPosition(scrollLeft);
                    });
                };
                
                // Adiciona listener de scroll no wrapper
                console.log('[setupStickyHeader] Adicionando listener no gantt-wrapper...');
                ganttWrapper.addEventListener('scroll', scrollSyncHandler, { passive: true });
                
                // Tamb√©m verifica se h√° scroll no container (caso o frappe-gantt use scroll interno)
                if (container && container !== ganttWrapper) {
                    console.log('[setupStickyHeader] Adicionando listener no gantt-container...');
                    container.addEventListener('scroll', scrollSyncHandler, { passive: true });
                }
                
                // IMPORTANTE: Busca TODOS os elementos que podem ter scroll dentro do wrapper
                const allScrollableElements = ganttWrapper.querySelectorAll('*');
                let scrollableFound = [];
                allScrollableElements.forEach(function(el) {
                    if (el.scrollWidth > el.clientWidth || el.scrollHeight > el.clientHeight) {
                        scrollableFound.push({
                            tag: el.tagName,
                            id: el.id,
                            class: el.className,
                            scrollWidth: el.scrollWidth,
                            clientWidth: el.clientWidth,
                            hasHorizontalScroll: el.scrollWidth > el.clientWidth
                        });
                        
                        // Adiciona listener neste elemento tamb√©m
                        if (el !== ganttWrapper && el !== container) {
                            el.addEventListener('scroll', scrollSyncHandler, { passive: true });
                            console.log('[setupStickyHeader] Listener adicionado em elemento scrollable:', el.tagName, el.id, el.className);
                        }
                    }
                });
                
                console.log('[setupStickyHeader] Elementos scrollable encontrados:', scrollableFound);
                
                // Sincroniza√ß√£o inicial (scrollLeft = 0)
                updateHeaderPosition();
                
                console.log('[setupStickyHeader] Listener de scroll horizontal adicionado (usando translateX)');
                console.log('[setupStickyHeader] Largura SVG:', svgWidth, 'px');
                console.log('[setupStickyHeader] ganttWrapper scroll info:', {
                    scrollWidth: ganttWrapper.scrollWidth,
                    clientWidth: ganttWrapper.clientWidth,
                    scrollLeft: ganttWrapper.scrollLeft,
                    hasHorizontalScroll: ganttWrapper.scrollWidth > ganttWrapper.clientWidth
                });
                
                // Garante que o cabe√ßalho tenha a mesma largura que o SVG para alinhamento correto
                // IMPORTANTE: O SVG clonado precisa ter a largura TOTAL para que translateX funcione
                // O container sticky controla o que √© vis√≠vel atrav√©s do overflow
                const syncWidth = function() {
                    if (stickyHeaderElement && headerSVG && svg) {
                        const svgWidth = parseFloat(svg.getAttribute('width') || svg.getBoundingClientRect().width || 0);
                        
                        if (svgWidth > 0) {
                            // O SVG clonado deve ter a mesma largura do SVG original
                            headerSVG.setAttribute('width', svgWidth);
                            headerSVG.style.width = svgWidth + 'px';
                            
                            // O container do cabe√ßalho deve ter 100% da largura do wrapper (√°rea vis√≠vel)
                            // Mas o SVG dentro dele tem a largura total e ser√° movido via translateX
                            stickyHeaderElement.style.width = '100%';
                            stickyHeaderElement.style.minWidth = 'auto';
                            stickyHeaderElement.style.maxWidth = 'none';
                            
                            console.log('[setupStickyHeader] Largura sincronizada - SVG:', svgWidth + 'px, Header: 100% do wrapper');
                        }
                    }
                };
                
                // Sincroniza largura inicial e ap√≥s mudan√ßas
                // Usa m√∫ltiplas tentativas para garantir que o SVG tenha dimens√µes v√°lidas
                const trySyncWidth = function(attempt) {
                    attempt = attempt || 1;
                    const svgWidth = parseFloat(svg.getAttribute('width') || svg.getBoundingClientRect().width || 0);
                    if (svgWidth > 0) {
                        syncWidth();
                    } else if (attempt < 5) {
                        setTimeout(function() {
                            trySyncWidth(attempt + 1);
                        }, 200 * attempt);
                    }
                };
                
                trySyncWidth(1);
                window.addEventListener('resize', function() {
                    setTimeout(syncWidth, 100);
                }, { passive: true });
                
                // Verifica se o cabe√ßalho est√° vis√≠vel e funcionando ap√≥s um delay
                setTimeout(function() {
                    const rect = stickyHeaderElement.getBoundingClientRect();
                    const wrapperRect = ganttWrapper.getBoundingClientRect();
                    const scrollTop = ganttWrapper.scrollTop;
                    
                    console.log('[setupStickyHeader] Verifica√ß√£o do cabe√ßalho ap√≥s 1s:', {
                        headerTop: rect.top,
                        wrapperTop: wrapperRect.top,
                        scrollTop: scrollTop,
                        headerVisible: rect.height > 0 && rect.width > 0,
                        headerInView: rect.top >= wrapperRect.top && rect.top < wrapperRect.bottom,
                        position: window.getComputedStyle(stickyHeaderElement).position
                    });
                    
                    // Se o sticky n√£o estiver funcionando (cabe√ßalho n√£o est√° no topo quando h√° scroll),
                    // usa fallback com JavaScript
                    if (scrollTop > 10 && rect.top > wrapperRect.top + 5) {
                        console.warn('[setupStickyHeader] Sticky n√£o est√° funcionando, usando fallback JavaScript');
                        // Fallback: usa position: fixed com JavaScript
                        stickyHeaderElement.style.position = 'fixed';
                        stickyHeaderElement.style.top = wrapperRect.top + 'px';
                        stickyHeaderElement.style.left = wrapperRect.left + 'px';
                        stickyHeaderElement.style.width = wrapperRect.width + 'px';
                        
                        // Atualiza posi√ß√£o quando o wrapper scrolla ou a janela √© redimensionada
                        const updateFixedPosition = function() {
                            const newWrapperRect = ganttWrapper.getBoundingClientRect();
                            stickyHeaderElement.style.top = newWrapperRect.top + 'px';
                            stickyHeaderElement.style.left = newWrapperRect.left + 'px';
                            stickyHeaderElement.style.width = newWrapperRect.width + 'px';
                        };
                        
                        ganttWrapper.addEventListener('scroll', updateFixedPosition, { passive: true });
                        window.addEventListener('scroll', updateFixedPosition, { passive: true });
                        window.addEventListener('resize', updateFixedPosition, { passive: true });
                        
                        console.log('[setupStickyHeader] Fallback JavaScript ativado');
                    } else {
                        console.log('[setupStickyHeader] ‚úì Sticky est√° funcionando corretamente');
                    }
                }, 1000);
                
                console.log('[setupStickyHeader] ‚úì Cabe√ßalho fixo criado com sucesso (altura:', headerHeight + 'px)');
                console.log('[setupStickyHeader] Elemento criado:', stickyHeaderElement);
                console.log('[setupStickyHeader] Estilos aplicados:', {
                    position: window.getComputedStyle(stickyHeaderElement).position,
                    top: window.getComputedStyle(stickyHeaderElement).top,
                    zIndex: window.getComputedStyle(stickyHeaderElement).zIndex,
                    display: window.getComputedStyle(stickyHeaderElement).display,
                    visibility: window.getComputedStyle(stickyHeaderElement).visibility
                });
                return true;
            };
            
            // Tenta criar o cabe√ßalho fixo ap√≥s renderiza√ß√£o inicial
            // Usa m√∫ltiplas tentativas para garantir que o SVG est√° completamente renderizado
            const trySetupStickyHeader = function(attempt) {
                attempt = attempt || 1;
                const maxAttempts = 10; // Aumentado para 10 tentativas
                
                console.log('Tentativa', attempt, 'de criar cabe√ßalho fixo...');
                
                const result = setupStickyHeader();
                if (result) {
                    console.log('‚úì Cabe√ßalho fixo criado com sucesso na tentativa', attempt);
                } else {
                    console.warn('‚úó Falha ao criar cabe√ßalho fixo na tentativa', attempt);
                    if (attempt < maxAttempts) {
                        // Tenta novamente ap√≥s um delay maior a cada tentativa
                        const delay = 300 * attempt; // Delay progressivo
                        console.log('Tentando novamente em', delay, 'ms...');
                        setTimeout(function() {
                            trySetupStickyHeader(attempt + 1);
                        }, delay);
                    } else {
                        console.error('‚ùå N√£o foi poss√≠vel criar cabe√ßalho fixo ap√≥s', maxAttempts, 'tentativas');
                        // Tenta uma √∫ltima vez ap√≥s um delay maior
                        setTimeout(function() {
                            console.log('Tentativa final de criar cabe√ßalho fixo...');
                            setupStickyHeader();
                        }, 2000);
                    }
                }
            };
            
            // Primeira tentativa ap√≥s 500ms (reduzido para come√ßar mais cedo)
            setTimeout(function() {
                console.log('Iniciando tentativas de criar cabe√ßalho fixo...');
                trySetupStickyHeader(1);
            }, 500);
            
            // Fun√ß√£o global para ocultar o cabe√ßalho original do Gantt (reutiliz√°vel)
            window.hideGanttOriginalHeader = function(targetSvg, headerHeight) {
                if (!targetSvg) {
                    const container = document.getElementById('gantt-container');
                    if (container) {
                        targetSvg = container.querySelector('svg');
                    }
                }
                if (!targetSvg) return;
                
                if (!headerHeight) {
                    headerHeight = ganttConfig.header_height || 100;
                }
                
                // 1. Tenta encontrar o grupo <g class="date"> diretamente
                const dateGroup = targetSvg.querySelector('g.date');
                if (dateGroup && dateGroup.style.display !== 'none') {
                    console.log('[hideGanttOriginalHeader] ‚úì Encontrado <g class="date"> - ocultando...');
                    dateGroup.style.display = 'none';
                    dateGroup.setAttribute('data-hidden-by-sticky', 'true');
                } else {
                    // 2. Se n√£o encontrar, procura pelo segundo <g> dentro do SVG
                    const allGroups = Array.from(targetSvg.querySelectorAll('g'));
                    if (allGroups.length >= 2) {
                        const secondGroup = allGroups[1]; // g[2] = √≠ndice 1
                        // Verifica se √© o cabe√ßalho (cont√©m textos com Y < headerHeight)
                        const hasHeaderTexts = Array.from(secondGroup.querySelectorAll('text')).some(function(text) {
                            const y = parseFloat(text.getAttribute('y') || '9999');
                            return y >= 0 && y < headerHeight;
                        });
                        
                        if (hasHeaderTexts && secondGroup.style.display !== 'none') {
                            console.log('[hideGanttOriginalHeader] ‚úì Encontrado cabe√ßalho no segundo <g> - ocultando...');
                            secondGroup.style.display = 'none';
                            secondGroup.setAttribute('data-hidden-by-sticky', 'true');
                        }
                    }
                }
                
                // 3. Ocultar tamb√©m outros elementos do cabe√ßalho (linhas, ret√¢ngulos) que possam estar soltos
                Array.from(targetSvg.querySelectorAll('*')).forEach(function(el) {
                    // Pula se j√° foi ocultado ou se √© um grupo de barras
                    if (el.hasAttribute('data-hidden-by-sticky') || el.closest('g.bar-wrapper')) {
                        return;
                    }
                    
                    const y = parseFloat(el.getAttribute('y') || '9999');
                    // Oculta elementos que est√£o na √°rea do cabe√ßalho
                    if (y >= 0 && y < headerHeight) {
                        // Verifica se n√£o √© uma barra de progresso
                        const height = parseFloat(el.getAttribute('height') || '0');
                        const isBar = height > 8 && height < 60;
                        
                        // Ocultar linhas, ret√¢ngulos e outros elementos do cabe√ßalho
                        if (!isBar && (el.tagName === 'line' || el.tagName === 'rect' || el.tagName === 'text')) {
                            el.style.display = 'none';
                            el.setAttribute('data-hidden-by-sticky', 'true');
                        }
                    }
                });
            };
            
            // FASE 3: INTERCEPTAR RE-RENDERIZA√á√ïES DO FRAPPE-GANTT
            // Intercepta mudan√ßas de view mode do frappe-gantt para garantir reaplica√ß√£o de cores
            // FASE 6: Tamb√©m recria cabe√ßalho fixo quando view_mode mudar
            if (gantt && typeof gantt.change_view_mode === 'function') {
                const originalChangeViewMode = gantt.change_view_mode;
                gantt.change_view_mode = function(mode) {
                    console.log('change_view_mode chamado com modo:', mode);
                    const result = originalChangeViewMode.call(this, mode);
                    
                    // Recria cabe√ßalho fixo ap√≥s mudan√ßa de view mode
                    // Aguarda renderiza√ß√£o completa do SVG antes de recriar
                    setTimeout(function() {
                        console.log('[change_view_mode] Recriando cabe√ßalho fixo ap√≥s mudan√ßa para:', mode);
                        const result = setupStickyHeader();
                        if (!result) {
                            console.warn('[change_view_mode] Falha ao recriar cabe√ßalho, tentando novamente...');
                            setTimeout(function() {
                                setupStickyHeader();
                            }, 500);
                        }
                    }, 300);
                    
                    // Recria√ß√£o adicional ap√≥s mais tempo (caso o SVG demore mais para renderizar)
                    setTimeout(function() {
                        console.log('[change_view_mode] Segunda tentativa de recriar cabe√ßalho fixo...');
                        setupStickyHeader();
                    }, 800);
                    
                    // Terceira tentativa ap√≥s ainda mais tempo
                    setTimeout(function() {
                        console.log('[change_view_mode] Terceira tentativa de recriar cabe√ßalho fixo...');
                        setupStickyHeader();
                    }, 1500);
                    
                    // Reaplica cores ap√≥s mudan√ßa de view mode
                    // Usa m√∫ltiplos timeouts para garantir que o SVG foi completamente re-renderizado
                    setTimeout(function() {
                        if (typeof window.applyGanttColors === 'function') {
                            console.log('Reaplicando cores ap√≥s mudan√ßa de view mode para:', mode);
                            window.applyGanttColors();
                        }
                    }, 300);
                    
                    // Reaplica√ß√£o adicional ap√≥s mais tempo (caso o SVG demore mais para renderizar)
                    setTimeout(function() {
                        if (typeof window.applyGanttColors === 'function') {
                            window.applyGanttColors();
                        }
                    }, 800);
                    
                    
                    return result;
                };
                console.log('Intercepta√ß√£o de change_view_mode configurada');
            }
            
            // Adiciona MutationObserver para reaplicar cores quando o SVG for modificado
            // IMPORTANTE: Configurado para ignorar mudan√ßas que n√≥s mesmos causamos
            const containerForObserver = document.getElementById('gantt-container');
            if (containerForObserver) {
                let observerTimeout = null;
                
                const observer = new MutationObserver(function(mutations) {
                    // Ignora se estamos aplicando cores (evita loop infinito)
                    if (isApplyingColors) {
                        return;
                    }
                    
                    // FASE 3: LOGS DETALHADOS DE MUDAN√áAS NO DOM
                    let relevantMutations = [];
                    let shouldReapply = false;
                    
                    mutations.forEach(function(mutation) {
                        const target = mutation.target;
                        const isRect = target.tagName === 'rect';
                        const isGroup = target.tagName === 'g';
                        const isSVG = target.tagName === 'SVG';
                        
                        // Loga mudan√ßas relevantes
                        if (mutation.type === 'attributes') {
                            const attrName = mutation.attributeName;
                            
                            // Se √© mudan√ßa em fill, stroke, style ou data-item-id
                            if (attrName === 'fill' || attrName === 'stroke' || attrName === 'style' || attrName === 'data-item-id') {
                                const hasDataItemId = target.hasAttribute && target.hasAttribute('data-item-id');
                                const hasDataCustomColor = target.hasAttribute && target.hasAttribute('data-custom-color');
                                
                                // Se n√£o tem nossos marcadores, pode ser re-renderiza√ß√£o do frappe-gantt
                                if (!hasDataItemId && !hasDataCustomColor) {
                                    shouldReapply = true;
                                    relevantMutations.push({
                                        type: 'attribute',
                                        target: isRect ? 'rect' : (isGroup ? 'g' : target.tagName),
                                        attribute: attrName,
                                        hasDataItemId: hasDataItemId,
                                        hasDataCustomColor: hasDataCustomColor
                                    });
                                } else if (attrName === 'data-item-id' || attrName === 'fill' || attrName === 'stroke') {
                                    // Se nossos atributos est√£o sendo removidos, √© problema!
                                    relevantMutations.push({
                                        type: 'attribute_removed',
                                        target: isRect ? 'rect' : (isGroup ? 'g' : target.tagName),
                                        attribute: attrName,
                                        oldValue: mutation.oldValue
                                    });
                                    shouldReapply = true;
                                }
                            }
                        }
                        
                        // Mudan√ßas na estrutura (childList) s√£o sempre relevantes
                        if (mutation.type === 'childList') {
                            const addedNodes = mutation.addedNodes.length;
                            const removedNodes = mutation.removedNodes.length;
                            
                            if (addedNodes > 0 || removedNodes > 0) {
                                shouldReapply = true;
                                relevantMutations.push({
                                    type: 'structure',
                                    target: isSVG ? 'SVG' : (isGroup ? 'g' : target.tagName),
                                    added: addedNodes,
                                    removed: removedNodes
                                });
                            }
                        }
                    });
                    
                    // Loga mudan√ßas relevantes (apenas primeiras 5 para n√£o poluir)
                    if (relevantMutations.length > 0 && relevantMutations.length <= 5) {
                        console.log('=== MUTATIONOBSERVER: Mudan√ßas detectadas ===');
                        relevantMutations.forEach(function(mut, idx) {
                            console.log(`  Muta√ß√£o ${idx + 1}:`, mut);
                        });
                    }
                    
                    if (shouldReapply) {
                        // Debounce: cancela timeout anterior e cria novo
                        if (observerTimeout) {
                            clearTimeout(observerTimeout);
                        }
                        
                        // Aguarda um pouco antes de reaplicar para evitar loops e agrupar m√∫ltiplas mudan√ßas
                        observerTimeout = setTimeout(function() {
                            // Verifica novamente se n√£o estamos aplicando cores
                            if (isApplyingColors) {
                                return;
                            }
                            
                            // Aplica cores apenas se n√£o estiver em execu√ß√£o
                            if (!isApplyingColors && typeof window.applyGanttColors === 'function') {
                                window.applyGanttColors();
                            }
                            
                            // IMPORTANTE: Garante que o cabe√ßalho original continue oculto ap√≥s mudan√ßas no SVG
                            if (typeof window.hideGanttOriginalHeader === 'function') {
                                window.hideGanttOriginalHeader(null, ganttConfig.header_height || 100);
                            }
                        }, 500); // Aumentado para 500ms para evitar reaplica√ß√µes muito frequentes
                    }
                });
                
                // Observa mudan√ßas no container, mas apenas em childList (estrutura)
                // N√£o observa attributes para evitar detectar nossas pr√≥prias mudan√ßas
                observer.observe(containerForObserver, {
                    childList: true,
                    subtree: true,
                    attributes: false // Desabilitado para evitar loop - s√≥ detectamos mudan√ßas estruturais
                });
                
                console.log('MutationObserver configurado (apenas mudan√ßas estruturais)');
            }
            
            // FASE 3: VERIFICA√á√ÉO PERI√ìDICA SE CORES AINDA EST√ÉO APLICADAS
            // Verifica periodicamente se as cores foram removidas e as reaplica se necess√°rio
            let colorCheckInterval = null;
            let lastColorCheck = 0;
            
            const checkColorsPeriodically = function() {
                const now = Date.now();
                // Verifica a cada 2 segundos
                if (now - lastColorCheck < 2000) {
                    return;
                }
                lastColorCheck = now;
                
                // N√£o verifica se est√° aplicando cores
                if (isApplyingColors) {
                    return;
                }
                
                const svg = container.querySelector('svg');
                if (!svg) return;
                
                // Verifica alguns itens aleat√≥rios para ver se cores ainda est√£o aplicadas
                let missingColors = 0;
                let checkedItems = 0;
                
                // Verifica primeiros 20 itens
                // CORRE√á√ÉO: Define colors localmente se n√£o estiver no escopo
                const localColors = {
                    'gantt-project': { fill: '#1a73e8', stroke: '#1a73e8', strokeWidth: '2' },
                    'gantt-macro': { fill: '#34a853', stroke: '#34a853', strokeWidth: '1.5' },
                    'gantt-stage': { fill: '#fbbc04', stroke: '#fbbc04', strokeWidth: '1' },
                    'gantt-task': { fill: '#9aa0a6', stroke: '#9aa0a6', strokeWidth: '0.5' }
                };
                
                timelineData.slice(0, 20).forEach(function(item) {
                    if (!item || !item.custom_class) return;
                    
                    const itemColors = localColors[item.custom_class];
                    if (!itemColors) return;
                    
                    // Encontra barras com data-item-id
                    const bars = svg.querySelectorAll('rect[data-item-id="' + item.id + '"]');
                    
                    if (bars.length > 0) {
                        checkedItems++;
                        bars.forEach(function(bar) {
                            const computedFill = window.getComputedStyle(bar).fill;
                            const attrFill = bar.getAttribute('fill') || '';
                            
                            // Verifica se a cor est√° correta
                            const fillMatches = attrFill === itemColors.fill || 
                                               computedFill === itemColors.fill ||
                                               (computedFill.startsWith('rgb') && computedFill.includes('26') && computedFill.includes('115') && computedFill.includes('232')); // RGB de #1a73e8
                            
                            if (!fillMatches && computedFill !== 'none' && computedFill !== '' && computedFill !== 'transparent') {
                                missingColors++;
                                if (missingColors <= 3) {
                                    console.warn('‚ö† Verifica√ß√£o peri√≥dica: Cor perdida para', item.name.trim(), '- Reaplicando...');
                                }
                            }
                        });
                    }
                });
                
                // Se encontrou cores faltando, reaplica
                if (missingColors > 0 && checkedItems > 0) {
                    console.warn('‚ö† Verifica√ß√£o peri√≥dica:', missingColors, 'barras com cores incorretas de', checkedItems, 'verificadas - Reaplicando cores...');
                    if (typeof window.applyGanttColors === 'function') {
                        window.applyGanttColors();
                    }
                }
            };
            
            // Inicia verifica√ß√£o peri√≥dica ap√≥s 3 segundos
            setTimeout(function() {
                colorCheckInterval = setInterval(checkColorsPeriodically, 2000);
                console.log('Verifica√ß√£o peri√≥dica de cores iniciada (a cada 2 segundos)');
            }, 3000);
            
            
            // Atualiza o callback de clique para usar o mapa de metadados
            if (gantt && gantt.change_view_mode) {
                // O callback on_click j√° foi definido, mas vamos garantir que funciona
                console.log('Callbacks configurados');
            }
        } catch (error) {
            console.error('Erro ao inicializar Gantt:', error);
            console.error('Tipo do erro:', error.constructor.name);
            console.error('Stack completo:', error.stack);
            console.error('Dados originais (primeiros 5):', timelineData ? timelineData.slice(0, 5) : 'N/A');
            
            let errorMessage = 'Erro ao renderizar o gr√°fico Gantt: ' + (error.message || 'Erro desconhecido');
            if (error.stack) {
                errorMessage += '<br><small style="color: #666;">Detalhes t√©cnicos: ' + error.stack.split('\n')[0] + '</small>';
            }
            
            container.innerHTML = '<div style="padding: 20px; text-align: center; color: #d00; background-color: #ffe5e5; border: 1px solid #d00; border-radius: 4px;">' +
                '<p style="margin: 0 0 10px 0;"><strong>' + errorMessage + '</strong></p>' +
                '<p style="margin: 0; font-size: 0.9rem;">Verifique o console do navegador (F12) para mais detalhes.</p>' +
                '</div>';
        }
    } else {
        // Se n√£o houver dados, mostra mensagem
        console.log('Nenhum dado dispon√≠vel');
        container.innerHTML = '<p style="padding: 20px; text-align: center; color: #666;">Nenhum dado dispon√≠vel para exibir no cronograma. Verifique se h√° projetos com datas v√°lidas (start_date e end_date) no banco de dados.</p>';
    }
});
</script>

<style>
/* Estilos customizados para o Gantt */
#gantt-container {
    width: 100%;
    background-color: #fff;
    /* Removido border, border-radius e padding para n√£o interferir no sticky */
    /* border: 1px solid #ddd; */
    /* border-radius: 4px; */
    /* padding: 10px; */
}

/* Garantir que o SVG seja vis√≠vel */
#gantt-container svg {
    display: block !important;
    visibility: visible !important;
    opacity: 1 !important;
}

/* SOLU√á√ÉO SIMPLIFICADA: CSS para cabe√ßalho fixo */
#gantt-wrapper {
    position: relative;
    overflow-y: auto;
    overflow-x: auto;
    max-height: 800px;
    background-color: #fff;
    /* Garante que o sticky funcione - n√£o pode ter overflow: hidden no pai */
    display: block;
}

#gantt-container {
    position: relative;
}

/* Cabe√ßalho fixo usando position: sticky */
.gantt-sticky-header {
    position: -webkit-sticky !important; /* Safari */
    position: sticky !important;
    top: 0 !important;
    left: 0 !important;
    z-index: 1000 !important;
    background: white !important;
    height: 115px !important; /* 110px do SVG + 5px margem */
    overflow: hidden !important;
    border-bottom: 2px solid #ccc !important;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1) !important;
    transition: box-shadow 0.2s ease;
    will-change: scroll-position;
    /* A largura ser√° definida dinamicamente via JavaScript para corresponder ao SVG total */
    margin: 0 !important;
    padding: 0 !important; /* Sem padding para n√£o interferir */
    display: block !important;
    visibility: visible !important;
    /* Garante que o cabe√ßalho n√£o quebre o layout */
    box-sizing: border-box;
}

/* Garante que o SVG dentro do cabe√ßalho seja exibido corretamente */
.gantt-sticky-header svg {
    display: block !important;
    margin: 0 !important;
    padding: 0 !important;
    visibility: visible !important;
    overflow: visible !important; /* N√£o corta conte√∫do */
    /* O SVG ser√° movido via translate3d para sincronizar com o scroll horizontal */
    will-change: transform !important;
    backface-visibility: hidden !important; /* Otimiza performance de transform */
    -webkit-backface-visibility: hidden !important;
}

/* Ajustes para responsividade */
@media (max-width: 768px) {
    #gantt-container {
        overflow-x: scroll;
    }
}

/* Cores por n√≠vel hier√°rquico - fallback via CSS */
/* Esquema de cores distintas (padr√£o) */
#gantt-container.color-scheme-colors svg .bar[data-project],
#gantt-container.color-scheme-colors svg g[data-task-id^="project-"] .bar {
    fill: #1a73e8 !important;
    stroke: #1a73e8 !important;
    stroke-width: 2px !important;
}

#gantt-container.color-scheme-colors svg .bar[data-macro],
#gantt-container.color-scheme-colors svg g[data-task-id^="macro-"] .bar {
    fill: #34a853 !important;
    stroke: #34a853 !important;
    stroke-width: 1.5px !important;
}

#gantt-container.color-scheme-colors svg .bar[data-stage],
#gantt-container.color-scheme-colors svg g[data-task-id^="stage-"] .bar {
    fill: #fbbc04 !important;
    stroke: #fbbc04 !important;
    stroke-width: 1px !important;
}

#gantt-container.color-scheme-colors svg .bar[data-task],
#gantt-container.color-scheme-colors svg g[data-task-id^="task-"] .bar {
    fill: #9aa0a6 !important;
    stroke: #9aa0a6 !important;
    stroke-width: 0.5px !important;
}


/* Estilos de texto por n√≠vel hier√°rquico */
.gantt-project {
    font-weight: bold;
}

.gantt-macro {
    font-weight: 500;
}

.gantt-stage {
    font-weight: normal;
}

.gantt-task {
    font-weight: normal;
    font-style: italic;
}
</style>
{% endblock %}

